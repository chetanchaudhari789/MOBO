[{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\app.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\config\\dotenvLoader.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\config\\env.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\controllers\\adminController.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\controllers\\authController.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\controllers\\brandController.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\controllers\\inviteController.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\controllers\\notificationsController.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\controllers\\opsController.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\controllers\\ordersController.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\controllers\\productsController.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\controllers\\pushNotificationsController.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\controllers\\ticketsController.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\database\\mongo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\app.js","messages":[{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'no-console').","line":87,"column":17,"severity":1,"nodeType":null,"fix":{"range":[3451,3489],"text":" "}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import express from 'express';\nimport cors from 'cors';\nimport helmet from 'helmet';\nimport rateLimit from 'express-rate-limit';\nimport crypto from 'node:crypto';\nimport { parseCorsOrigins } from './config/env.js';\nimport { healthRoutes } from './routes/healthRoutes.js';\nimport { authRoutes } from './routes/authRoutes.js';\nimport { adminRoutes } from './routes/adminRoutes.js';\nimport { opsRoutes } from './routes/opsRoutes.js';\nimport { productsRoutes } from './routes/productsRoutes.js';\nimport { aiRoutes } from './routes/aiRoutes.js';\nimport { ordersRoutes } from './routes/ordersRoutes.js';\nimport { ticketsRoutes } from './routes/ticketsRoutes.js';\nimport { brandRoutes } from './routes/brandRoutes.js';\nimport { notificationsRoutes } from './routes/notificationsRoutes.js';\nimport { realtimeRoutes } from './routes/realtimeRoutes.js';\nimport { errorHandler, notFoundHandler } from './middleware/errors.js';\nimport { mediaRoutes } from './routes/mediaRoutes.js';\nfunction isOriginAllowed(origin, allowed) {\n    if (!origin)\n        return true;\n    if (!allowed.length)\n        return true;\n    if (allowed.includes('*'))\n        return true;\n    let originUrl = null;\n    try {\n        originUrl = new URL(origin);\n    }\n    catch {\n        // If Origin is not a valid URL, fail closed.\n        return false;\n    }\n    const originHost = originUrl.hostname;\n    return allowed.some((entryRaw) => {\n        const entry = String(entryRaw || '').trim();\n        if (!entry)\n            return false;\n        // Exact match (full origin string).\n        if (!entry.includes('*') && (entry.startsWith('http://') || entry.startsWith('https://'))) {\n            return entry === origin;\n        }\n        // Wildcard support.\n        // Examples:\n        // - https://*.vercel.app\n        // - *.vercel.app\n        // - https://mobobuyer.vercel.app\n        if (entry.includes('*')) {\n            const escaped = entry\n                .replace(/[.+?^${}()|[\\]\\\\]/g, '\\\\$&')\n                .replace(/\\*/g, '.*');\n            const re = new RegExp(`^${escaped}$`);\n            return re.test(origin) || re.test(originHost);\n        }\n        // Hostname-only entry support.\n        // Examples:\n        // - mobobuyer.vercel.app\n        // - .vercel.app (suffix)\n        if (entry.startsWith('.'))\n            return originHost.endsWith(entry);\n        return originHost === entry;\n    });\n}\nexport function createApp(env) {\n    const app = express();\n    app.disable('x-powered-by');\n    // Ensure every response carries a request identifier for log correlation.\n    // If a caller provides X-Request-Id, we echo it back (within a safe length).\n    app.use((req, res, next) => {\n        const provided = String(req.header('x-request-id') || '').trim();\n        const requestId = provided && provided.length <= 128 ? provided : crypto.randomUUID();\n        res.setHeader('x-request-id', requestId);\n        res.locals.requestId = requestId;\n        next();\n    });\n    // Most deployments (Render/Vercel/NGINX) run behind a reverse proxy.\n    // This ensures `req.ip` and rate-limits behave correctly.\n    app.set('trust proxy', 1);\n    // Lightweight request logging (kept dependency-free).\n    // Disabled in tests to avoid noisy output.\n    if (env.NODE_ENV !== 'test') {\n        app.use((req, res, next) => {\n            const start = Date.now();\n            res.on('finish', () => {\n                const ms = Date.now() - start;\n                // eslint-disable-next-line no-console\n                console.log(`[${String(res.locals.requestId || '-')}] ${req.method} ${req.originalUrl} -> ${res.statusCode} (${ms}ms)`);\n            });\n            next();\n        });\n    }\n    // Helmet defaults are good, but for an API service we explicitly:\n    // - disable CSP (frontends are served separately)\n    // - only enable HSTS in production\n    app.use(helmet({\n        contentSecurityPolicy: false,\n        crossOriginEmbedderPolicy: false,\n        hsts: env.NODE_ENV === 'production',\n    }));\n    app.use(rateLimit({\n        windowMs: 60_000,\n        limit: env.NODE_ENV === 'production' ? 300 : 10_000,\n        standardHeaders: true,\n        legacyHeaders: false,\n        handler: (_req, res) => {\n            const requestId = String(res.locals?.requestId || res.getHeader?.('x-request-id') || '').trim();\n            res.status(429).json({\n                error: { code: 'RATE_LIMITED', message: 'Too many requests' },\n                requestId,\n            });\n        },\n    }));\n    // Stricter limiter for authentication endpoints to reduce brute-force risk.\n    const authLimiter = rateLimit({\n        windowMs: 5 * 60_000,\n        limit: env.NODE_ENV === 'production' ? 50 : 1000,\n        standardHeaders: true,\n        legacyHeaders: false,\n    });\n    const corsOrigins = parseCorsOrigins(env.CORS_ORIGINS);\n    // If a request presents an Origin header and it is not allowed, fail closed.\n    // This complements the CORS middleware (which otherwise may simply omit headers\n    // while still allowing the request to be processed server-side).\n    app.use((req, res, next) => {\n        const origin = req.header('origin');\n        if (origin && !isOriginAllowed(origin, corsOrigins)) {\n            return res.status(403).json({\n                error: 'origin_not_allowed',\n                requestId: String(res.locals.requestId || ''),\n            });\n        }\n        next();\n    });\n    app.use(cors({\n        origin: (origin, cb) => cb(null, isOriginAllowed(String(origin || ''), corsOrigins)),\n        credentials: true,\n        optionsSuccessStatus: 204,\n    }));\n    app.use(express.json({ limit: env.REQUEST_BODY_LIMIT }));\n    app.use(express.urlencoded({ extended: false, limit: env.REQUEST_BODY_LIMIT }));\n    app.use('/api', healthRoutes(env));\n    app.use('/api/auth', authLimiter, authRoutes(env));\n    app.use('/api/admin', adminRoutes(env));\n    app.use('/api/ops', opsRoutes(env));\n    app.use('/api/brand', brandRoutes(env));\n    app.use('/api', productsRoutes(env));\n    app.use('/api', ordersRoutes(env));\n    app.use('/api', ticketsRoutes(env));\n    app.use('/api/notifications', notificationsRoutes(env));\n    app.use('/api/realtime', realtimeRoutes(env));\n    app.use('/api', mediaRoutes(env));\n    app.use('/api/ai', aiRoutes(env));\n    app.use(notFoundHandler);\n    app.use(errorHandler);\n    return app;\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\config\\dotenvLoader.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\config\\env.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\controllers\\adminController.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\controllers\\authController.js","messages":[{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'no-await-in-loop').","line":370,"column":25,"severity":1,"nodeType":null,"fix":{"range":[19317,19361],"text":" "}},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'no-await-in-loop').","line":477,"column":25,"severity":1,"nodeType":null,"fix":{"range":[25105,25149],"text":" "}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import jwt from 'jsonwebtoken';\nimport mongoose from 'mongoose';\nimport { AppError } from '../middleware/errors.js';\nimport { UserModel } from '../models/User.js';\nimport { hashPassword, verifyPassword } from '../services/passwords.js';\nimport { signAccessToken, signRefreshToken } from '../services/tokens.js';\nimport { loginSchema, registerBrandSchema, registerOpsSchema, registerSchema, refreshSchema, updateProfileSchema, } from '../validations/auth.js';\nimport { InviteModel } from '../models/Invite.js';\nimport { generateHumanCode } from '../services/codes.js';\nimport { writeAuditLog } from '../services/audit.js';\nimport { consumeInvite } from '../services/invites.js';\nimport { ensureWallet } from '../services/walletService.js';\nimport { toUiUser } from '../utils/uiMappers.js';\nimport { ensureRoleDocumentsForUser } from '../services/roleDocuments.js';\nimport { publishRealtime } from '../services/realtimeHub.js';\nimport { getAgencyCodeForMediatorCode } from '../services/lineage.js';\nexport function makeAuthController(env) {\n    async function withTransaction(fn) {\n        const session = await mongoose.startSession();\n        try {\n            let out;\n            await session.withTransaction(async () => {\n                out = await fn(session);\n            });\n            return out;\n        }\n        finally {\n            session.endSession();\n        }\n    }\n    return {\n        me: async (req, res, next) => {\n            try {\n                const userId = String(req.auth?.userId || '').trim();\n                if (!userId) {\n                    throw new AppError(401, 'UNAUTHENTICATED', 'Missing auth context');\n                }\n                const user = await UserModel.findById(userId);\n                if (!user || user.deletedAt) {\n                    throw new AppError(401, 'UNAUTHENTICATED', 'User not found');\n                }\n                // `requireAuth` already enforces active status + upstream suspension.\n                const wallet = await ensureWallet(String(user._id));\n                res.json({ user: toUiUser(user, wallet) });\n            }\n            catch (err) {\n                next(err);\n            }\n        },\n        register: async (req, res, next) => {\n            try {\n                const body = registerSchema.parse(req.body);\n                const existing = await UserModel.findOne({ mobile: body.mobile, deletedAt: null }).lean();\n                if (existing) {\n                    throw new AppError(409, 'MOBILE_ALREADY_EXISTS', 'Mobile already registered');\n                }\n                const passwordHash = await hashPassword(body.password);\n                // Atomic: validate + create user + (optional) consume invite.\n                const { user, consumed } = await withTransaction(async (session) => {\n                    // Preferred: invite-based registration.\n                    const invite = await InviteModel.findOne({ code: body.mediatorCode, status: 'active' })\n                        .session(session)\n                        .lean();\n                    let upstreamMediatorCode = '';\n                    let consume = null;\n                    if (invite) {\n                        if (String(invite.role) !== 'shopper') {\n                            throw new AppError(400, 'INVITE_ROLE_MISMATCH', 'Invite role mismatch');\n                        }\n                        const maxUses = Number(invite.maxUses ?? 1);\n                        const useCount = Number(invite.useCount ?? 0);\n                        if (useCount >= maxUses) {\n                            throw new AppError(400, 'INVALID_INVITE', 'Invalid or inactive invite code');\n                        }\n                        upstreamMediatorCode = String(invite.parentCode || '').trim();\n                        if (!upstreamMediatorCode) {\n                            throw new AppError(400, 'INVALID_INVITE', 'Invite missing parent mediator code');\n                        }\n                        consume = { code: body.mediatorCode, role: 'shopper' };\n                    }\n                    else {\n                        // Fallback: allow registering with an upstream mediator code directly.\n                        upstreamMediatorCode = String(body.mediatorCode || '').trim();\n                        if (!upstreamMediatorCode) {\n                            throw new AppError(400, 'INVALID_INVITE', 'Invalid or inactive invite code');\n                        }\n                    }\n                    // Parent mediator must be active.\n                    const mediator = await UserModel.findOne({\n                        mediatorCode: upstreamMediatorCode,\n                        roles: 'mediator',\n                        status: 'active',\n                        deletedAt: null,\n                    })\n                        .session(session)\n                        .lean();\n                    if (!mediator) {\n                        throw new AppError(400, 'INVALID_INVITE_PARENT', 'Invite parent mediator is not valid');\n                    }\n                    const created = await UserModel.create([\n                        {\n                            name: body.name,\n                            mobile: body.mobile,\n                            email: body.email,\n                            passwordHash,\n                            role: 'shopper',\n                            roles: ['shopper'],\n                            status: 'active',\n                            parentCode: upstreamMediatorCode,\n                            isVerifiedByMediator: false,\n                        },\n                    ], { session });\n                    const newUser = created[0];\n                    await ensureRoleDocumentsForUser({ user: newUser, session });\n                    const consumedInvite = consume\n                        ? await consumeInvite({\n                            code: consume.code,\n                            role: consume.role,\n                            usedByUserId: String(newUser._id),\n                            session,\n                        })\n                        : null;\n                    return { user: newUser, consumed: consumedInvite };\n                });\n                if (consumed) {\n                    await writeAuditLog({\n                        req,\n                        action: 'INVITE_USED',\n                        entityType: 'Invite',\n                        entityId: String(consumed._id),\n                        metadata: { code: consumed.code, role: consumed.role, usedBy: String(user._id) },\n                    });\n                    // Realtime: keep admin invite list accurate (status/useCount/usedAt).\n                    // Do not broadcast invite codes; scope to privileged roles.\n                    publishRealtime({\n                        type: 'invites.changed',\n                        ts: new Date().toISOString(),\n                        audience: { roles: ['admin', 'ops'] },\n                    });\n                }\n                const accessToken = signAccessToken(env, String(user._id), user.roles);\n                const refreshToken = signRefreshToken(env, String(user._id), user.roles);\n                const wallet = await ensureWallet(String(user._id));\n                // Realtime: a buyer created via a mediator code must show up immediately in the mediator portal\n                // for approve/reject workflows (and in the upstream agency view).\n                const upstreamMediatorCode = String(user?.parentCode || '').trim();\n                if (upstreamMediatorCode) {\n                    const agencyCode = (await getAgencyCodeForMediatorCode(upstreamMediatorCode)) || '';\n                    const ts = new Date().toISOString();\n                    publishRealtime({\n                        type: 'users.changed',\n                        ts,\n                        payload: { userId: String(user._id), kind: 'buyer', mediatorCode: upstreamMediatorCode },\n                        audience: {\n                            mediatorCodes: [upstreamMediatorCode],\n                            ...(agencyCode ? { agencyCodes: [agencyCode] } : {}),\n                            roles: ['admin', 'ops'],\n                        },\n                    });\n                    publishRealtime({\n                        type: 'notifications.changed',\n                        ts,\n                        payload: { source: 'buyer.registered', userId: String(user._id) },\n                        audience: {\n                            mediatorCodes: [upstreamMediatorCode],\n                            ...(agencyCode ? { agencyCodes: [agencyCode] } : {}),\n                            roles: ['admin', 'ops'],\n                        },\n                    });\n                }\n                res.status(201).json({\n                    user: toUiUser(user, wallet),\n                    tokens: { accessToken, refreshToken },\n                });\n            }\n            catch (err) {\n                next(err);\n            }\n        },\n        login: async (req, res, next) => {\n            try {\n                const body = loginSchema.parse(req.body);\n                const password = body.password;\n                const mobile = typeof body.mobile === 'string' ? String(body.mobile).trim() : '';\n                const usernameRaw = typeof body.username === 'string' ? String(body.username).trim() : '';\n                const username = usernameRaw ? usernameRaw.toLowerCase() : '';\n                const user = mobile\n                    ? await UserModel.findOne({ mobile, deletedAt: null })\n                    : await UserModel.findOne({ username, role: { $in: ['admin', 'ops'] }, deletedAt: null });\n                if (!user) {\n                    await writeAuditLog({\n                        req,\n                        action: 'AUTH_LOGIN_FAILED',\n                        metadata: { reason: 'user_not_found', mobile: mobile || undefined, username: username || undefined },\n                    });\n                    throw new AppError(401, 'INVALID_CREDENTIALS', 'Invalid credentials');\n                }\n                // Admin/ops must use username login (mobile is not accepted for these roles).\n                if (mobile) {\n                    const primaryRole = String(user.role || '').toLowerCase();\n                    const roles = Array.isArray(user.roles) ? user.roles.map((r) => String(r).toLowerCase()) : [];\n                    const isAdminOrOps = primaryRole === 'admin' || primaryRole === 'ops' || roles.includes('admin') || roles.includes('ops');\n                    if (isAdminOrOps) {\n                        await writeAuditLog({\n                            req,\n                            action: 'AUTH_LOGIN_FAILED',\n                            actorUserId: String(user._id),\n                            metadata: { reason: 'username_required' },\n                        });\n                        throw new AppError(400, 'USERNAME_REQUIRED', 'Admin login requires username and password');\n                    }\n                }\n                if (user.status !== 'active') {\n                    await writeAuditLog({\n                        req,\n                        action: 'AUTH_LOGIN_FAILED',\n                        actorUserId: String(user._id),\n                        metadata: { reason: 'user_not_active', status: user.status },\n                    });\n                    throw new AppError(403, 'USER_NOT_ACTIVE', 'User is not active');\n                }\n                const ok = await verifyPassword(password, user.passwordHash);\n                if (!ok) {\n                    await writeAuditLog({\n                        req,\n                        action: 'AUTH_LOGIN_FAILED',\n                        actorUserId: String(user._id),\n                        metadata: { reason: 'invalid_password' },\n                    });\n                    throw new AppError(401, 'INVALID_CREDENTIALS', 'Invalid credentials');\n                }\n                const accessToken = signAccessToken(env, String(user._id), user.roles);\n                const refreshToken = signRefreshToken(env, String(user._id), user.roles);\n                const wallet = await ensureWallet(String(user._id));\n                await writeAuditLog({\n                    req,\n                    action: 'AUTH_LOGIN_SUCCESS',\n                    actorUserId: String(user._id),\n                    actorRoles: user.roles,\n                    metadata: { role: user.role },\n                });\n                res.json({\n                    user: toUiUser(user, wallet),\n                    tokens: { accessToken, refreshToken },\n                });\n            }\n            catch (err) {\n                next(err);\n            }\n        },\n        refresh: async (req, res, next) => {\n            try {\n                const body = refreshSchema.parse(req.body);\n                const refreshToken = String(body.refreshToken || '').trim();\n                if (!refreshToken)\n                    throw new AppError(401, 'UNAUTHENTICATED', 'Missing refresh token');\n                let decoded;\n                try {\n                    decoded = jwt.verify(refreshToken, env.JWT_REFRESH_SECRET, { algorithms: ['HS256'] });\n                }\n                catch {\n                    throw new AppError(401, 'UNAUTHENTICATED', 'Invalid or expired refresh token');\n                }\n                if (decoded?.typ !== 'refresh') {\n                    throw new AppError(401, 'UNAUTHENTICATED', 'Invalid refresh token');\n                }\n                const userId = String(decoded.sub || '').trim();\n                if (!userId)\n                    throw new AppError(401, 'UNAUTHENTICATED', 'Invalid refresh token');\n                const user = await UserModel.findById(userId).lean();\n                if (!user || user.deletedAt) {\n                    throw new AppError(401, 'UNAUTHENTICATED', 'User not found');\n                }\n                if (user.status !== 'active') {\n                    throw new AppError(403, 'USER_NOT_ACTIVE', 'User is not active');\n                }\n                const accessToken = signAccessToken(env, String(user._id), user.roles);\n                const newRefreshToken = signRefreshToken(env, String(user._id), user.roles);\n                const wallet = await ensureWallet(String(user._id));\n                res.json({\n                    user: toUiUser(user, wallet),\n                    tokens: { accessToken, refreshToken: newRefreshToken },\n                });\n            }\n            catch (err) {\n                next(err);\n            }\n        },\n        registerOps: async (req, res, next) => {\n            try {\n                const body = registerOpsSchema.parse(req.body);\n                const existing = await UserModel.findOne({ mobile: body.mobile, deletedAt: null }).lean();\n                if (existing) {\n                    throw new AppError(409, 'MOBILE_ALREADY_EXISTS', 'Mobile already registered');\n                }\n                const passwordHash = await hashPassword(body.password);\n                const { user, consumed, pendingApproval } = await withTransaction(async (session) => {\n                    const isMediatorJoin = body.role === 'mediator';\n                    // Preferred: invite-based.\n                    const invite = await InviteModel.findOne({ code: body.code, status: 'active' })\n                        .session(session)\n                        .lean();\n                    let parentCode;\n                    let createdBy;\n                    let consume = null;\n                    let pendingApproval = false;\n                    if (invite) {\n                        if (String(invite.role) !== String(body.role)) {\n                            throw new AppError(400, 'INVITE_ROLE_MISMATCH', 'Invite role mismatch');\n                        }\n                        const maxUses = Number(invite.maxUses ?? 1);\n                        const useCount = Number(invite.useCount ?? 0);\n                        if (useCount >= maxUses) {\n                            throw new AppError(400, 'INVALID_INVITE', 'Invalid or inactive invite code');\n                        }\n                        parentCode = invite.parentCode ?? undefined;\n                        createdBy = invite.createdBy;\n                        consume = { code: body.code, role: body.role };\n                    }\n                    else {\n                        // Fallback: allow a mediator to join an agency using the agency's code.\n                        if (!isMediatorJoin) {\n                            throw new AppError(400, 'INVALID_INVITE', 'Invalid or inactive invite code');\n                        }\n                        // This flow must NOT auto-activate the mediator. It should create a pending request\n                        // that the agency can approve/reject.\n                        pendingApproval = true;\n                        const agencyCode = String(body.code || '').trim();\n                        if (!agencyCode) {\n                            throw new AppError(400, 'INVALID_INVITE', 'Invalid or inactive invite code');\n                        }\n                        const agency = await UserModel.findOne({\n                            mediatorCode: agencyCode,\n                            roles: 'agency',\n                            status: 'active',\n                            deletedAt: null,\n                        })\n                            .session(session)\n                            .lean();\n                        if (!agency) {\n                            throw new AppError(400, 'INVALID_INVITE_PARENT', 'Invite parent agency is not valid');\n                        }\n                        const agencyParentCode = String(agency.mediatorCode || '').trim();\n                        if (!agencyParentCode) {\n                            throw new AppError(400, 'INVALID_INVITE_PARENT', 'Invite parent agency is not valid');\n                        }\n                        parentCode = agencyParentCode;\n                    }\n                    if (body.role === 'mediator') {\n                        const agencyCode = String(parentCode || '').trim();\n                        if (!agencyCode) {\n                            throw new AppError(400, 'INVALID_INVITE', 'Mediator join requires an agency code');\n                        }\n                        const agency = await UserModel.findOne({\n                            mediatorCode: agencyCode,\n                            roles: 'agency',\n                            status: 'active',\n                            deletedAt: null,\n                        })\n                            .session(session)\n                            .lean();\n                        if (!agency) {\n                            throw new AppError(400, 'INVALID_INVITE_PARENT', 'Invite parent agency is not valid');\n                        }\n                    }\n                    const roles = body.role === 'agency' ? ['agency'] : ['mediator'];\n                    const mediatorCodePrefix = body.role === 'agency' ? 'AGY' : 'MED';\n                    let mediatorCode = generateHumanCode(mediatorCodePrefix);\n                    for (let i = 0; i < 5; i += 1) {\n                        // eslint-disable-next-line no-await-in-loop\n                        const codeExists = await UserModel.exists({ mediatorCode }).session(session);\n                        if (!codeExists)\n                            break;\n                        mediatorCode = generateHumanCode(mediatorCodePrefix);\n                    }\n                    const created = await UserModel.create([\n                        {\n                            name: body.name,\n                            mobile: body.mobile,\n                            passwordHash,\n                            role: body.role,\n                            roles: [...roles],\n                            status: pendingApproval ? 'pending' : 'active',\n                            mediatorCode,\n                            parentCode: parentCode,\n                            kycStatus: 'pending',\n                            createdBy,\n                        },\n                    ], { session });\n                    const newUser = created[0];\n                    await ensureRoleDocumentsForUser({ user: newUser, session });\n                    const consumedInvite = consume\n                        ? await consumeInvite({\n                            code: consume.code,\n                            role: consume.role,\n                            usedByUserId: String(newUser._id),\n                            session,\n                        })\n                        : null;\n                    return { user: newUser, consumed: consumedInvite, pendingApproval };\n                });\n                if (consumed) {\n                    await writeAuditLog({\n                        req,\n                        action: 'INVITE_USED',\n                        entityType: 'Invite',\n                        entityId: String(consumed._id),\n                        metadata: { code: consumed.code, role: consumed.role, usedBy: String(user._id) },\n                    });\n                    publishRealtime({\n                        type: 'invites.changed',\n                        ts: new Date().toISOString(),\n                        audience: { roles: ['admin', 'ops'] },\n                    });\n                }\n                // If mediator joined via agency code, the account is pending and must be approved by agency.\n                if (pendingApproval) {\n                    // Realtime: agency portal must see mediator join requests instantly.\n                    const agencyCode = String(user?.parentCode || '').trim();\n                    if (agencyCode) {\n                        const ts = new Date().toISOString();\n                        publishRealtime({\n                            type: 'users.changed',\n                            ts,\n                            payload: { userId: String(user._id), kind: 'mediator', status: 'pending', agencyCode },\n                            audience: { agencyCodes: [agencyCode], roles: ['admin', 'ops'] },\n                        });\n                        publishRealtime({\n                            type: 'notifications.changed',\n                            ts,\n                            payload: { source: 'mediator.join.requested', userId: String(user._id), agencyCode },\n                            audience: { agencyCodes: [agencyCode], roles: ['admin', 'ops'] },\n                        });\n                    }\n                    res.status(202).json({\n                        pendingApproval: true,\n                        message: 'Request sent to agency for approval',\n                    });\n                    return;\n                }\n                const accessToken = signAccessToken(env, String(user._id), user.roles);\n                const refreshToken = signRefreshToken(env, String(user._id), user.roles);\n                const wallet = await ensureWallet(String(user._id));\n                res.status(201).json({ user: toUiUser(user, wallet), tokens: { accessToken, refreshToken } });\n            }\n            catch (err) {\n                next(err);\n            }\n        },\n        registerBrand: async (req, res, next) => {\n            try {\n                const body = registerBrandSchema.parse(req.body);\n                const existing = await UserModel.findOne({ mobile: body.mobile, deletedAt: null }).lean();\n                if (existing) {\n                    throw new AppError(409, 'MOBILE_ALREADY_EXISTS', 'Mobile already registered');\n                }\n                const passwordHash = await hashPassword(body.password);\n                const { user, consumed } = await withTransaction(async (session) => {\n                    // Brand registration MUST be invite-based.\n                    // The UI field is currently named `brandCode` but must contain an invite code.\n                    const invite = await InviteModel.findOne({ code: body.brandCode, status: 'active' })\n                        .session(session)\n                        .lean();\n                    if (!invite)\n                        throw new AppError(400, 'INVALID_INVITE', 'Invalid or inactive invite code');\n                    if (String(invite.role) !== 'brand') {\n                        throw new AppError(400, 'INVITE_ROLE_MISMATCH', 'Invite role mismatch');\n                    }\n                    const maxUses = Number(invite.maxUses ?? 1);\n                    const useCount = Number(invite.useCount ?? 0);\n                    if (useCount >= maxUses) {\n                        throw new AppError(400, 'INVALID_INVITE', 'Invalid or inactive invite code');\n                    }\n                    // Generate a stable brand code for downstream linking (Brand -> Agency connections).\n                    let brandCode = generateHumanCode('BRD');\n                    for (let i = 0; i < 5; i += 1) {\n                        // eslint-disable-next-line no-await-in-loop\n                        const exists = await UserModel.exists({ brandCode }).session(session);\n                        if (!exists)\n                            break;\n                        brandCode = generateHumanCode('BRD');\n                    }\n                    const created = await UserModel.create([\n                        {\n                            name: body.name,\n                            mobile: body.mobile,\n                            passwordHash,\n                            role: 'brand',\n                            roles: ['brand'],\n                            status: 'active',\n                            brandCode,\n                            createdBy: invite.createdBy,\n                        },\n                    ], { session });\n                    const newUser = created[0];\n                    await ensureRoleDocumentsForUser({ user: newUser, session });\n                    const consumedInvite = await consumeInvite({\n                        code: body.brandCode,\n                        role: 'brand',\n                        usedByUserId: String(newUser._id),\n                        session,\n                    });\n                    return { user: newUser, consumed: consumedInvite };\n                });\n                await writeAuditLog({\n                    req,\n                    action: 'INVITE_USED',\n                    entityType: 'Invite',\n                    entityId: String(consumed._id),\n                    metadata: { code: consumed.code, role: consumed.role, usedBy: String(user._id) },\n                });\n                publishRealtime({\n                    type: 'invites.changed',\n                    ts: new Date().toISOString(),\n                    audience: { roles: ['admin', 'ops'] },\n                });\n                const accessToken = signAccessToken(env, String(user._id), user.roles);\n                const refreshToken = signRefreshToken(env, String(user._id), user.roles);\n                const wallet = await ensureWallet(String(user._id));\n                res.status(201).json({\n                    user: toUiUser(user, wallet),\n                    tokens: { accessToken, refreshToken },\n                });\n            }\n            catch (err) {\n                next(err);\n            }\n        },\n        updateProfile: async (req, res, next) => {\n            try {\n                const body = updateProfileSchema.parse(req.body);\n                const requesterId = req.auth?.userId;\n                if (!requesterId) {\n                    throw new AppError(401, 'UNAUTHENTICATED', 'Missing auth context');\n                }\n                const targetUserId = body.userId ?? requesterId;\n                const requester = await UserModel.findById(requesterId);\n                if (!requester)\n                    throw new AppError(401, 'UNAUTHENTICATED', 'User not found');\n                const isSelf = String(targetUserId) === String(requesterId);\n                const isAdmin = requester.roles?.includes('admin') || requester.roles?.includes('ops');\n                if (!isSelf && !isAdmin) {\n                    throw new AppError(403, 'FORBIDDEN', 'Cannot update other user profile');\n                }\n                const update = {};\n                for (const key of ['name', 'email', 'avatar', 'upiId', 'qrCode']) {\n                    const value = body[key];\n                    if (typeof value === 'undefined')\n                        continue;\n                    if (typeof value === 'string' && value.trim() === '')\n                        continue;\n                    update[key] = value;\n                }\n                if (typeof body.bankDetails !== 'undefined') {\n                    const raw = body.bankDetails;\n                    if (raw && typeof raw === 'object') {\n                        const cleaned = {};\n                        for (const k of ['accountNumber', 'ifsc', 'bankName', 'holderName']) {\n                            const v = raw[k];\n                            if (typeof v === 'undefined')\n                                continue;\n                            if (typeof v === 'string' && v.trim() === '')\n                                continue;\n                            cleaned[k] = v;\n                        }\n                        if (Object.keys(cleaned).length)\n                            update.bankDetails = cleaned;\n                    }\n                }\n                const user = await UserModel.findByIdAndUpdate(targetUserId, update, { new: true });\n                if (!user)\n                    throw new AppError(404, 'USER_NOT_FOUND', 'User not found');\n                // Keep role-specific collections consistent with the canonical User record.\n                await ensureRoleDocumentsForUser({ user });\n                // Realtime: reflect profile changes on other devices/sessions.\n                publishRealtime({\n                    type: 'users.changed',\n                    ts: new Date().toISOString(),\n                    payload: { userId: String(user._id) },\n                    audience: { roles: ['admin', 'ops'], userIds: [String(user._id)] },\n                });\n                const wallet = await ensureWallet(String(user._id));\n                res.json({ user: toUiUser(user, wallet) });\n            }\n            catch (err) {\n                next(err);\n            }\n        },\n    };\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\controllers\\brandController.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\controllers\\inviteController.js","messages":[{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'no-await-in-loop').","line":18,"column":21,"severity":1,"nodeType":null,"fix":{"range":[950,994],"text":" "}},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'no-await-in-loop').","line":145,"column":21,"severity":1,"nodeType":null,"fix":{"range":[7219,7263],"text":" "}},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'no-await-in-loop').","line":199,"column":21,"severity":1,"nodeType":null,"fix":{"range":[10125,10169],"text":" "}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":3,"source":"import { InviteModel } from '../models/Invite.js';\nimport { createInviteSchema, opsGenerateInviteSchema, revokeInviteSchema } from '../validations/invites.js';\nimport { generateHumanCode } from '../services/codes.js';\nimport { AppError } from '../middleware/errors.js';\nimport { UserModel } from '../models/User.js';\nimport { writeAuditLog } from '../services/audit.js';\nimport { revokeInvite } from '../services/invites.js';\nimport { publishRealtime } from '../services/realtimeHub.js';\nexport function makeInviteController() {\n    return {\n        adminCreateInvite: async (req, res, next) => {\n            try {\n                const body = createInviteSchema.parse(req.body);\n                const ttlSeconds = body.ttlSeconds ?? 60 * 60 * 24 * 7;\n                const expiresAt = new Date(Date.now() + ttlSeconds * 1000);\n                let code = generateHumanCode('INV');\n                for (let i = 0; i < 5; i += 1) {\n                    // eslint-disable-next-line no-await-in-loop\n                    const exists = await InviteModel.exists({ code });\n                    if (!exists)\n                        break;\n                    code = generateHumanCode('INV');\n                }\n                const createdBy = req.auth?.userId ? req.auth.userId : undefined;\n                const invite = await InviteModel.create({\n                    code,\n                    role: body.role,\n                    label: body.label,\n                    parentUserId: body.parentUserId,\n                    parentCode: body.parentCode,\n                    maxUses: body.maxUses ?? 1,\n                    expiresAt,\n                    createdBy,\n                });\n                await writeAuditLog({\n                    req,\n                    action: 'INVITE_CREATED',\n                    entityType: 'Invite',\n                    entityId: String(invite._id),\n                    metadata: { code: invite.code, role: invite.role, parentCode: invite.parentCode, parentUserId: invite.parentUserId },\n                });\n                const privilegedRoles = ['admin', 'ops'];\n                publishRealtime({ type: 'invites.changed', ts: new Date().toISOString(), audience: { roles: privilegedRoles } });\n                res.status(201).json({\n                    code: invite.code,\n                    role: invite.role,\n                    label: invite.label,\n                    status: invite.status,\n                    expiresAt: invite.expiresAt,\n                });\n            }\n            catch (err) {\n                next(err);\n            }\n        },\n        adminRevokeInvite: async (req, res, next) => {\n            try {\n                const body = revokeInviteSchema.parse(req.body);\n                const revokedBy = req.auth?.userId;\n                if (!revokedBy)\n                    throw new AppError(401, 'UNAUTHENTICATED', 'Missing auth context');\n                const invite = await revokeInvite({ code: body.code, revokedByUserId: revokedBy, reason: body.reason });\n                await writeAuditLog({\n                    req,\n                    action: 'INVITE_REVOKED',\n                    entityType: 'Invite',\n                    entityId: String(invite._id),\n                    metadata: { code: invite.code, reason: body.reason },\n                });\n                const privilegedRoles = ['admin', 'ops'];\n                publishRealtime({ type: 'invites.changed', ts: new Date().toISOString(), audience: { roles: privilegedRoles } });\n                res.json({ ok: true });\n            }\n            catch (err) {\n                next(err);\n            }\n        },\n        adminListInvites: async (_req, res, next) => {\n            try {\n                const invites = await InviteModel.find({}).sort({ createdAt: -1 }).limit(500).lean();\n                res.json(invites);\n            }\n            catch (err) {\n                next(err);\n            }\n        },\n        adminDeleteInvite: async (req, res, next) => {\n            try {\n                const code = String(req.params.code || '').trim();\n                if (!code)\n                    throw new AppError(400, 'INVALID_INVITE_CODE', 'Invite code required');\n                const invite = await InviteModel.findOne({ code });\n                if (!invite)\n                    throw new AppError(404, 'INVITE_NOT_FOUND', 'Invite not found');\n                if (invite.status !== 'active') {\n                    throw new AppError(409, 'INVITE_NOT_ACTIVE', 'Invite is not active');\n                }\n                const useCount = Number(invite.useCount ?? 0);\n                const usesLen = Array.isArray(invite.uses) ? invite.uses.length : 0;\n                if (useCount > 0 || usesLen > 0 || invite.usedBy) {\n                    throw new AppError(409, 'INVITE_ALREADY_USED', 'Cannot delete an invite that has been used');\n                }\n                await writeAuditLog({\n                    req,\n                    action: 'INVITE_DELETED',\n                    entityType: 'Invite',\n                    entityId: String(invite._id),\n                    metadata: { code: invite.code, role: invite.role, parentCode: invite.parentCode, parentUserId: invite.parentUserId },\n                });\n                await invite.deleteOne();\n                const privilegedRoles = ['admin', 'ops'];\n                publishRealtime({ type: 'invites.changed', ts: new Date().toISOString(), audience: { roles: privilegedRoles } });\n                res.json({ ok: true });\n            }\n            catch (err) {\n                next(err);\n            }\n        },\n        opsGenerateMediatorInvite: async (req, res, next) => {\n            try {\n                const body = opsGenerateInviteSchema.parse(req.body);\n                const requesterId = req.auth?.userId;\n                if (!requesterId)\n                    throw new AppError(401, 'UNAUTHENTICATED', 'Missing auth context');\n                const requester = await UserModel.findById(requesterId);\n                if (!requester)\n                    throw new AppError(401, 'UNAUTHENTICATED', 'User not found');\n                // Allow agencies to generate mediator invites for themselves. Admin/Ops can generate for any agency.\n                const isAgencySelf = requester.roles?.includes('agency') && String(requester._id) === body.agencyId;\n                const isPrivileged = requester.roles?.includes('admin') || requester.roles?.includes('ops');\n                if (!isAgencySelf && !isPrivileged) {\n                    throw new AppError(403, 'FORBIDDEN', 'Cannot generate invites for this agency');\n                }\n                const agency = await UserModel.findById(body.agencyId);\n                if (!agency || !agency.roles?.includes('agency')) {\n                    throw new AppError(404, 'AGENCY_NOT_FOUND', 'Agency not found');\n                }\n                // Ensure agency has a stable code.\n                if (!agency.mediatorCode) {\n                    agency.mediatorCode = generateHumanCode('AGY');\n                    await agency.save();\n                }\n                let code = generateHumanCode('INV');\n                for (let i = 0; i < 5; i += 1) {\n                    // eslint-disable-next-line no-await-in-loop\n                    const exists = await InviteModel.exists({ code });\n                    if (!exists)\n                        break;\n                    code = generateHumanCode('INV');\n                }\n                const invite = await InviteModel.create({\n                    code,\n                    role: 'mediator',\n                    parentUserId: agency._id,\n                    parentCode: agency.mediatorCode,\n                    createdBy: requester._id,\n                    expiresAt: new Date(Date.now() + 1000 * 60 * 60 * 24 * 14),\n                });\n                await writeAuditLog({\n                    req,\n                    action: 'INVITE_CREATED',\n                    entityType: 'Invite',\n                    entityId: String(invite._id),\n                    metadata: { code: invite.code, role: invite.role, parentCode: invite.parentCode, parentUserId: invite.parentUserId },\n                });\n                const privilegedRoles = ['admin', 'ops'];\n                publishRealtime({ type: 'invites.changed', ts: new Date().toISOString(), audience: { roles: privilegedRoles } });\n                res.status(201).json({ code: invite.code });\n            }\n            catch (err) {\n                next(err);\n            }\n        },\n        opsGenerateBuyerInvite: async (req, res, next) => {\n            try {\n                const mediatorId = String((req.body?.mediatorId ?? '')).trim();\n                if (!mediatorId)\n                    throw new AppError(400, 'INVALID_MEDIATOR_ID', 'mediatorId required');\n                const requesterId = req.auth?.userId;\n                if (!requesterId)\n                    throw new AppError(401, 'UNAUTHENTICATED', 'Missing auth context');\n                const requester = await UserModel.findById(requesterId);\n                if (!requester)\n                    throw new AppError(401, 'UNAUTHENTICATED', 'User not found');\n                const isMediatorSelf = requester.roles?.includes('mediator') && String(requester._id) === mediatorId;\n                const isPrivileged = requester.roles?.includes('admin') || requester.roles?.includes('ops');\n                if (!isMediatorSelf && !isPrivileged) {\n                    throw new AppError(403, 'FORBIDDEN', 'Cannot generate buyer invites for this mediator');\n                }\n                const mediator = await UserModel.findById(mediatorId);\n                if (!mediator || !mediator.roles?.includes('mediator')) {\n                    throw new AppError(404, 'MEDIATOR_NOT_FOUND', 'Mediator not found');\n                }\n                if (!mediator.mediatorCode) {\n                    throw new AppError(409, 'MISSING_MEDIATOR_CODE', 'Mediator missing code');\n                }\n                let code = generateHumanCode('INV');\n                for (let i = 0; i < 5; i += 1) {\n                    // eslint-disable-next-line no-await-in-loop\n                    const exists = await InviteModel.exists({ code });\n                    if (!exists)\n                        break;\n                    code = generateHumanCode('INV');\n                }\n                const invite = await InviteModel.create({\n                    code,\n                    role: 'shopper',\n                    parentUserId: mediator._id,\n                    parentCode: mediator.mediatorCode,\n                    createdBy: requester._id,\n                    expiresAt: new Date(Date.now() + 1000 * 60 * 60 * 24 * 14),\n                });\n                await writeAuditLog({\n                    req,\n                    action: 'INVITE_CREATED',\n                    entityType: 'Invite',\n                    entityId: String(invite._id),\n                    metadata: { code: invite.code, role: invite.role, parentCode: invite.parentCode, parentUserId: invite.parentUserId },\n                });\n                const privilegedRoles = ['admin', 'ops'];\n                publishRealtime({ type: 'invites.changed', ts: new Date().toISOString(), audience: { roles: privilegedRoles } });\n                res.status(201).json({ code: invite.code });\n            }\n            catch (err) {\n                next(err);\n            }\n        },\n    };\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\controllers\\notificationsController.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\controllers\\opsController.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\controllers\\ordersController.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\controllers\\productsController.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\controllers\\pushNotificationsController.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\controllers\\ticketsController.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\database\\mongo.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\index.js","messages":[{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'no-console').","line":15,"column":5,"severity":1,"nodeType":null,"fix":{"range":[492,530],"text":" "}},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'no-console').","line":18,"column":9,"severity":1,"nodeType":null,"fix":{"range":[638,676],"text":" "}},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'no-console').","line":31,"column":9,"severity":1,"nodeType":null,"fix":{"range":[1005,1043],"text":" "}},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'no-console').","line":38,"column":9,"severity":1,"nodeType":null,"fix":{"range":[1189,1227],"text":" "}},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'no-console').","line":53,"column":9,"severity":1,"nodeType":null,"fix":{"range":[1573,1611],"text":" "}},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'no-console').","line":70,"column":9,"severity":1,"nodeType":null,"fix":{"range":[2149,2187],"text":" "}},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'no-console').","line":82,"column":9,"severity":1,"nodeType":null,"fix":{"range":[2517,2555],"text":" "}},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-var-requires').","line":89,"column":9,"severity":1,"nodeType":null,"fix":{"range":[2743,2805],"text":" "}},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'no-console').","line":95,"column":9,"severity":1,"nodeType":null,"fix":{"range":[2979,3017],"text":" "}},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'no-console').","line":126,"column":9,"severity":1,"nodeType":null,"fix":{"range":[4321,4359],"text":" "}},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'no-console').","line":133,"column":5,"severity":1,"nodeType":null,"fix":{"range":[4587,4625],"text":" "}},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'no-console').","line":139,"column":5,"severity":1,"nodeType":null,"fix":{"range":[4803,4841],"text":" "}},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'no-console').","line":145,"column":5,"severity":1,"nodeType":null,"fix":{"range":[4987,5025],"text":" "}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":13,"fixableErrorCount":0,"fixableWarningCount":13,"source":"import { loadDotenv } from './config/dotenvLoader.js';\nloadDotenv();\nimport { loadEnv } from './config/env.js';\nimport { connectMongo, disconnectMongo } from './database/mongo.js';\nimport { createApp } from './app.js';\nimport { createRequire } from 'node:module';\nconst require = createRequire(import.meta.url);\nlet server = null;\nlet shuttingDown = false;\nconst shutdownTimeoutMs = 30_000;\nasync function shutdown(signal) {\n    if (shuttingDown)\n        return;\n    shuttingDown = true;\n    // eslint-disable-next-line no-console\n    console.log(`Received ${signal}. Shutting down...`);\n    const forceTimer = setTimeout(() => {\n        // eslint-disable-next-line no-console\n        console.error('Force shutdown after timeout');\n        process.exit(1);\n    }, shutdownTimeoutMs);\n    forceTimer.unref();\n    try {\n        await new Promise((resolve) => {\n            if (!server)\n                return resolve();\n            server.close(() => resolve());\n        });\n    }\n    catch (err) {\n        // eslint-disable-next-line no-console\n        console.error('Error while closing HTTP server:', err);\n    }\n    try {\n        await disconnectMongo();\n    }\n    catch (err) {\n        // eslint-disable-next-line no-console\n        console.error('Error while disconnecting Mongo:', err);\n    }\n    finally {\n        clearTimeout(forceTimer);\n    }\n}\nasync function tryRunE2ESeed() {\n    try {\n        const mod = await import('./seeds/e2e.js');\n        if (typeof mod.seedE2E === 'function') {\n            await mod.seedE2E();\n        }\n    }\n    catch (err) {\n        // eslint-disable-next-line no-console\n        console.warn('SEED_E2E seed failed; skipping', err);\n    }\n}\nasync function tryRunAdminSeed() {\n    try {\n        const mod = await import('./seeds/admin.js');\n        if (typeof mod.seedAdminOnly === 'function') {\n            await mod.seedAdminOnly({\n                mobile: process.env.ADMIN_SEED_MOBILE,\n                username: process.env.ADMIN_SEED_USERNAME,\n                password: process.env.ADMIN_SEED_PASSWORD,\n                name: process.env.ADMIN_SEED_NAME,\n            });\n        }\n    }\n    catch {\n        // eslint-disable-next-line no-console\n        console.warn('SEED_ADMIN requested but seed module is missing (./seeds/admin.js); skipping');\n    }\n}\nasync function tryRunDevSeed() {\n    try {\n        const mod = await import('./seeds/dev.js');\n        if (typeof mod.seedDev === 'function') {\n            await mod.seedDev();\n        }\n    }\n    catch (err) {\n        // eslint-disable-next-line no-console\n        console.warn('SEED_DEV seed failed; skipping', err);\n    }\n}\nasync function tryRunLargeSeed(wipe) {\n    try {\n        // Optional module; do not require it at build-time.\n        // eslint-disable-next-line @typescript-eslint/no-var-requires\n        const mod = require('./seeds/seed.js');\n        if (typeof mod?.runLargeSeed === 'function')\n            await mod.runLargeSeed({ wipe });\n    }\n    catch {\n        // eslint-disable-next-line no-console\n        console.warn('SEED_LARGE requested but seed module is missing (./seeds/seed.js); skipping');\n    }\n}\nasync function main() {\n    const env = loadEnv();\n    await connectMongo(env);\n    const seedAdminRequested = env.SEED_ADMIN || process.env.SEED_ADMIN === 'true';\n    const seedE2ERequested = env.SEED_E2E || process.env.SEED_E2E === 'true';\n    const seedDevRequested = env.SEED_DEV || process.env.SEED_DEV === 'true';\n    const isProd = env.NODE_ENV === 'production';\n    // E2E/admin seeding is idempotent and explicitly opt-in.\n    // Allow it even when NODE_ENV=production so Playwright (and similar harnesses) work\n    // in environments that default NODE_ENV to production.\n    if (!isProd || seedAdminRequested || seedE2ERequested) {\n        if (seedDevRequested) {\n            if (isProd) {\n                throw new Error('SEED_DEV is not allowed in production');\n            }\n            await tryRunDevSeed();\n        }\n        if (seedAdminRequested)\n            await tryRunAdminSeed();\n        if (seedE2ERequested)\n            await tryRunE2ESeed();\n        if (!isProd && process.env.SEED_LARGE === 'true') {\n            await tryRunLargeSeed(process.env.SEED_WIPE === 'true');\n        }\n    }\n    const app = createApp(env);\n    server = app.listen(env.PORT, () => {\n        // eslint-disable-next-line no-console\n        console.log(`Backend listening on :${env.PORT}`);\n    });\n}\nprocess.on('SIGTERM', () => void shutdown('SIGTERM'));\nprocess.on('SIGINT', () => void shutdown('SIGINT'));\nprocess.on('unhandledRejection', (reason) => {\n    // eslint-disable-next-line no-console\n    console.error('Unhandled promise rejection:', reason);\n    process.exitCode = 1;\n    void shutdown('unhandledRejection');\n});\nprocess.on('uncaughtException', (err) => {\n    // eslint-disable-next-line no-console\n    console.error('Uncaught exception:', err);\n    process.exitCode = 1;\n    void shutdown('uncaughtException');\n});\nmain().catch((err) => {\n    // eslint-disable-next-line no-console\n    console.error('Fatal startup error:', err);\n    process.exitCode = 1;\n});\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\middleware\\auth.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\middleware\\errors.js","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_next' is defined but never used.","line":22,"column":45,"nodeType":"Identifier","messageId":"unusedVar","endLine":22,"endColumn":50},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'no-console').","line":86,"column":5,"severity":1,"nodeType":null,"fix":{"range":[2763,2801],"text":" "}}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { z } from 'zod';\nexport class AppError extends Error {\n    statusCode;\n    code;\n    details;\n    constructor(statusCode, code, message, details) {\n        super(message);\n        this.statusCode = statusCode;\n        this.code = code;\n        this.details = details;\n    }\n}\nexport function notFoundHandler(req, res) {\n    res.status(404).json({\n        error: {\n            code: 'NOT_FOUND',\n            message: `Route not found: ${req.method} ${req.path}`,\n        },\n        requestId: String(res.locals?.requestId || res.getHeader?.('x-request-id') || '').trim(),\n    });\n}\nexport function errorHandler(err, req, res, _next) {\n    const requestId = String(res.locals?.requestId || res.getHeader?.('x-request-id') || '').trim();\n    if (err instanceof AppError) {\n        res.status(err.statusCode).json({\n            error: {\n                code: err.code,\n                message: err.message,\n                details: err.details,\n            },\n            requestId,\n        });\n        return;\n    }\n    // Validation errors should never be 500s.\n    if (err instanceof z.ZodError) {\n        res.status(400).json({\n            error: {\n                code: 'BAD_REQUEST',\n                message: 'Invalid request',\n                details: err.issues,\n            },\n            requestId,\n        });\n        return;\n    }\n    // Common Mongoose failure when an endpoint expects an ObjectId but receives an invalid string.\n    const anyErr = err;\n    if (anyErr && anyErr.name === 'CastError') {\n        res.status(400).json({\n            error: {\n                code: 'INVALID_ID',\n                message: 'Invalid identifier',\n                details: { path: anyErr.path, value: anyErr.value },\n            },\n            requestId,\n        });\n        return;\n    }\n    // Malformed JSON from express.json() / body-parser should never be a 500.\n    // This commonly appears as a SyntaxError with type='entity.parse.failed'.\n    if (anyErr &&\n        (anyErr.type === 'entity.parse.failed' ||\n            (anyErr instanceof SyntaxError && Number(anyErr.status) === 400))) {\n        res.status(400).json({\n            error: {\n                code: 'BAD_JSON',\n                message: 'Malformed JSON body',\n            },\n            requestId,\n        });\n        return;\n    }\n    // Request body exceeds the configured limit (express.json's `limit` option).\n    if (anyErr && anyErr.type === 'entity.too.large') {\n        res.status(413).json({\n            error: {\n                code: 'PAYLOAD_TOO_LARGE',\n                message: 'Request body is too large. Please reduce the payload size.',\n            },\n            requestId,\n        });\n        return;\n    }\n    const isProd = process.env.NODE_ENV === 'production';\n    // eslint-disable-next-line no-console\n    console.error(`[${requestId || '-'}] Unhandled error on ${req.method} ${req.originalUrl}:`, err);\n    const message = isProd ? 'Unexpected error' : err instanceof Error ? err.message : 'Unexpected error';\n    res.status(500).json({\n        error: {\n            code: 'INTERNAL_SERVER_ERROR',\n            message,\n        },\n        requestId,\n    });\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\models\\Agency.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\models\\AuditLog.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\models\\Brand.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\models\\Campaign.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\models\\Deal.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\models\\Invite.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\models\\MediatorProfile.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\models\\Order.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\models\\Payout.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\models\\PushSubscription.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\models\\ShopperProfile.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\models\\Suspension.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\models\\SystemConfig.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\models\\Ticket.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\models\\Transaction.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\models\\User.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\models\\Wallet.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\routes\\adminRoutes.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\routes\\aiRoutes.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\routes\\authRoutes.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\routes\\brandRoutes.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\routes\\healthRoutes.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\routes\\mediaRoutes.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\routes\\notificationsRoutes.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\routes\\opsRoutes.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\routes\\ordersRoutes.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\routes\\productsRoutes.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\routes\\realtimeRoutes.js","messages":[{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-explicit-any').","line":70,"column":13,"severity":1,"nodeType":null,"fix":{"range":[3063,3125],"text":" "}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { Router } from 'express';\nimport { requireAuth } from '../middleware/auth.js';\nimport { subscribeRealtime } from '../services/realtimeHub.js';\nfunction writeSse(res, evt) {\n    // Never throw from a realtime emitter callback.\n    if (!res || res.writableEnded || res.destroyed)\n        return false;\n    try {\n        res.write(`event: ${evt.event}\\n`);\n        if (typeof evt.data !== 'undefined') {\n            const payload = typeof evt.data === 'string' ? evt.data : JSON.stringify(evt.data);\n            // SSE allows multi-line data; keep it single-line JSON.\n            res.write(`data: ${payload}\\n`);\n        }\n        res.write('\\n');\n        // If the runtime supports it, flush bytes immediately.\n        if (typeof res.flush === 'function')\n            res.flush();\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\nfunction shouldDeliver(evt, ctx) {\n    const aud = evt.audience;\n    // Fail closed: realtime events must declare an explicit audience.\n    // Use { audience: { broadcast: true } } for broadcasts.\n    if (!aud)\n        return false;\n    if (aud.broadcast)\n        return true;\n    if (Array.isArray(aud.userIds) && aud.userIds.includes(ctx.userId))\n        return true;\n    if (Array.isArray(aud.roles) && aud.roles.some((r) => ctx.roles.includes(r)))\n        return true;\n    // Multi-tenant audience targeting by code fields\n    const normalizeCode = (v) => String(v || '').trim().toLowerCase();\n    const mediatorCodeNorm = normalizeCode(ctx.mediatorCode || '');\n    const parentCodeNorm = normalizeCode(ctx.parentCode || '');\n    const brandCodeNorm = normalizeCode(ctx.brandCode || '');\n    if (mediatorCodeNorm && ctx.roles.includes('agency') && Array.isArray(aud.agencyCodes) &&\n        aud.agencyCodes.map((c) => normalizeCode(c)).includes(mediatorCodeNorm))\n        return true;\n    if (mediatorCodeNorm && ctx.roles.includes('mediator') && Array.isArray(aud.mediatorCodes) &&\n        aud.mediatorCodes.map((c) => normalizeCode(c)).includes(mediatorCodeNorm))\n        return true;\n    if (brandCodeNorm && ctx.roles.includes('brand') && Array.isArray(aud.brandCodes) &&\n        aud.brandCodes.map((c) => normalizeCode(c)).includes(brandCodeNorm))\n        return true;\n    if (parentCodeNorm && Array.isArray(aud.parentCodes) &&\n        aud.parentCodes.map((c) => normalizeCode(c)).includes(parentCodeNorm))\n        return true;\n    return false;\n}\nexport function realtimeRoutes(env) {\n    const r = Router();\n    // Lightweight health check for the realtime subsystem.\n    // Does not require auth and does not open a long-lived SSE stream.\n    r.get('/health', (_req, res) => {\n        res.status(200).json({ status: 'ok' });\n    });\n    // Streaming endpoint for realtime UI updates.\n    // Auth is via standard Bearer token header (same as REST routes).\n    r.get('/stream', requireAuth(env), (req, res) => {\n        // Avoid proxy / load balancer / Node defaults closing the connection.\n        try {\n            req.socket.setNoDelay(true);\n            req.socket.setTimeout(0);\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            res.setTimeout?.(0);\n        }\n        catch {\n            // ignore\n        }\n        // Important headers for SSE.\n        res.status(200);\n        res.setHeader('Content-Type', 'text/event-stream; charset=utf-8');\n        res.setHeader('Cache-Control', 'no-cache, no-transform');\n        res.setHeader('Connection', 'keep-alive');\n        // Some proxies buffer by default.\n        res.setHeader('X-Accel-Buffering', 'no');\n        // Flush headers if supported (depends on runtime).\n        if (typeof res.flushHeaders === 'function')\n            res.flushHeaders();\n        const userId = String(req.auth?.userId || '');\n        const roles = (req.auth?.roles || []);\n        const mediatorCode = String(req.auth?.user?.mediatorCode || '').trim();\n        const parentCode = String(req.auth?.user?.parentCode || '').trim();\n        const brandCode = String(req.auth?.user?.brandCode || '').trim();\n        let cleaned = false;\n        let ping = null;\n        let unsubscribe = null;\n        const cleanup = () => {\n            if (cleaned)\n                return;\n            cleaned = true;\n            try {\n                if (ping)\n                    clearInterval(ping);\n            }\n            catch {\n                // ignore\n            }\n            try {\n                unsubscribe?.();\n            }\n            catch {\n                // ignore\n            }\n            try {\n                res.end();\n            }\n            catch {\n                // ignore\n            }\n        };\n        // Initial handshake.\n        try {\n            res.write(': connected\\n\\n');\n            if (typeof res.flush === 'function')\n                res.flush();\n        }\n        catch {\n            cleanup();\n            return;\n        }\n        if (!writeSse(res, { event: 'ready', data: { ts: new Date().toISOString() } })) {\n            cleanup();\n            return;\n        }\n        unsubscribe = subscribeRealtime((evt) => {\n            if (!shouldDeliver(evt, { userId, roles, mediatorCode, parentCode, brandCode }))\n                return;\n            if (!writeSse(res, { event: evt.type, data: { ts: evt.ts, payload: evt.payload } })) {\n                cleanup();\n            }\n        });\n        // Keepalive ping so intermediaries donΓÇÖt close idle connections.\n        ping = setInterval(() => {\n            if (!writeSse(res, { event: 'ping', data: { ts: new Date().toISOString() } })) {\n                cleanup();\n            }\n        }, 25_000);\n        req.on('close', cleanup);\n        req.on('aborted', cleanup);\n        res.on('close', cleanup);\n        res.on('error', cleanup);\n    });\n    return r;\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\routes\\ticketsRoutes.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\seeds\\admin.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\seeds\\dev.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\seeds\\e2e.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\seeds\\seed.js","messages":[{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'no-await-in-loop').","line":355,"column":13,"severity":1,"nodeType":null,"fix":{"range":[14353,14397],"text":" "}},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'no-await-in-loop').","line":411,"column":9,"severity":1,"nodeType":null,"fix":{"range":[16678,16722],"text":" "}},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'no-await-in-loop').","line":447,"column":9,"severity":1,"nodeType":null,"fix":{"range":[18370,18414],"text":" "}},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'no-await-in-loop').","line":451,"column":9,"severity":1,"nodeType":null,"fix":{"range":[18534,18578],"text":" "}},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'no-await-in-loop').","line":466,"column":9,"severity":1,"nodeType":null,"fix":{"range":[19269,19313],"text":" "}},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'no-console').","line":475,"column":5,"severity":1,"nodeType":null,"fix":{"range":[19682,19720],"text":" "}},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'no-console').","line":477,"column":5,"severity":1,"nodeType":null,"fix":{"range":[19767,19805],"text":" "}},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'no-console').","line":514,"column":9,"severity":1,"nodeType":null,"fix":{"range":[21293,21331],"text":" "}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":8,"source":"import { loadDotenv } from '../config/dotenvLoader.js';\nloadDotenv();\nimport { faker } from '@faker-js/faker';\nimport seedrandom from 'seedrandom';\nimport { loadEnv } from '../config/env.js';\nimport { connectMongo } from '../database/mongo.js';\nimport { UserModel } from '../models/User.js';\nimport { WalletModel } from '../models/Wallet.js';\nimport { AgencyModel } from '../models/Agency.js';\nimport { BrandModel } from '../models/Brand.js';\nimport { MediatorProfileModel } from '../models/MediatorProfile.js';\nimport { ShopperProfileModel } from '../models/ShopperProfile.js';\nimport { CampaignModel } from '../models/Campaign.js';\nimport { DealModel } from '../models/Deal.js';\nimport { OrderModel } from '../models/Order.js';\nimport { TicketModel } from '../models/Ticket.js';\nimport { PayoutModel } from '../models/Payout.js';\nimport { TransactionModel } from '../models/Transaction.js';\nimport { InviteModel } from '../models/Invite.js';\nimport { AuditLogModel } from '../models/AuditLog.js';\nimport { SuspensionModel } from '../models/Suspension.js';\nimport { hashPassword } from '../services/passwords.js';\nimport { applyWalletCredit } from '../services/walletService.js';\nimport { ensureWallet } from '../services/walletService.js';\nimport { disconnectMongo } from '../database/mongo.js';\nfunction makeIndianMobile() {\n    // deterministic via global seeded RNG\n    const n = faker.number.int({ min: 0, max: 9_999_999_999 });\n    return `91${String(n).padStart(10, '0')}`;\n}\nfunction parseArgs() {\n    const seed = process.env.SEED ?? 'mobo-seed';\n    const usersPerRole = Number(process.env.SEED_USERS_PER_ROLE ?? '500');\n    const campaigns = Number(process.env.SEED_CAMPAIGNS ?? '200');\n    const dealsPerMediator = Number(process.env.SEED_DEALS_PER_MEDIATOR ?? '10');\n    const orders = Number(process.env.SEED_ORDERS ?? String(usersPerRole));\n    const tickets = Number(process.env.SEED_TICKETS ?? String(Math.max(25, Math.floor(orders / 10))));\n    const payouts = Number(process.env.SEED_PAYOUTS ?? String(Math.max(10, Math.floor(usersPerRole / 10))));\n    return { seed, usersPerRole, campaigns, dealsPerMediator, orders, tickets, payouts };\n}\nasync function wipe() {\n    await Promise.all([\n        UserModel.deleteMany({}),\n        WalletModel.deleteMany({}),\n        TransactionModel.deleteMany({}),\n        AgencyModel.deleteMany({}),\n        BrandModel.deleteMany({}),\n        MediatorProfileModel.deleteMany({}),\n        ShopperProfileModel.deleteMany({}),\n        CampaignModel.deleteMany({}),\n        DealModel.deleteMany({}),\n        OrderModel.deleteMany({}),\n        TicketModel.deleteMany({}),\n        PayoutModel.deleteMany({}),\n        InviteModel.deleteMany({}),\n        AuditLogModel.deleteMany({}),\n        SuspensionModel.deleteMany({}),\n    ]);\n}\nconst DEFAULT_PASSWORD = 'ChangeMe_123!';\nexport async function runLargeSeed(params) {\n    const env = loadEnv();\n    const opts = parseArgs();\n    await connectMongo(env);\n    // Deterministic randomness\n    seedrandom(opts.seed, { global: true });\n    faker.seed(Math.abs(opts.seed.split('').reduce((a, c) => a + c.charCodeAt(0), 0)));\n    const doWipe = params?.wipe ?? process.env.SEED_WIPE === 'true';\n    if (!doWipe) {\n        throw new Error('Refusing to seed without SEED_WIPE=true (prevents accidental wipes).');\n    }\n    await wipe();\n    const defaultPasswordHash = await hashPassword(DEFAULT_PASSWORD);\n    // Stable demo accounts (used by portals + E2E)\n    const admin = await UserModel.create({\n        name: 'Master Admin',\n        mobile: 'admin',\n        passwordHash: defaultPasswordHash,\n        role: 'admin',\n        roles: ['admin'],\n        status: 'active',\n    });\n    const demoAgencyCode = 'AGY_TEST';\n    const demoMediatorCode = 'MED_TEST';\n    const demoBrandCode = 'BRD_TEST';\n    const demoAgency = await UserModel.create({\n        name: 'Demo Agency',\n        mobile: '9000000001',\n        passwordHash: defaultPasswordHash,\n        role: 'agency',\n        roles: ['agency'],\n        status: 'active',\n        mediatorCode: demoAgencyCode,\n        kycStatus: 'verified',\n    });\n    await AgencyModel.create({\n        name: 'Demo Agency',\n        agencyCode: demoAgencyCode,\n        ownerUserId: demoAgency._id,\n        status: 'active',\n    });\n    const demoMediator = await UserModel.create({\n        name: 'Demo Mediator',\n        mobile: '9000000002',\n        passwordHash: defaultPasswordHash,\n        role: 'mediator',\n        roles: ['mediator'],\n        status: 'active',\n        mediatorCode: demoMediatorCode,\n        parentCode: demoAgencyCode,\n        kycStatus: 'verified',\n    });\n    await MediatorProfileModel.create({\n        userId: demoMediator._id,\n        mediatorCode: demoMediatorCode,\n        parentAgencyCode: demoAgencyCode,\n        status: 'active',\n    });\n    const demoBrand = await UserModel.create({\n        name: 'Demo Brand',\n        mobile: '9000000003',\n        passwordHash: defaultPasswordHash,\n        role: 'brand',\n        roles: ['brand'],\n        status: 'active',\n        brandCode: demoBrandCode,\n    });\n    await BrandModel.create({\n        name: 'Demo Brand',\n        brandCode: demoBrandCode,\n        ownerUserId: demoBrand._id,\n        status: 'active',\n        connectedAgencyCodes: [demoAgencyCode],\n    });\n    const demoShopper = await UserModel.create({\n        name: 'Demo Buyer',\n        mobile: '9000000004',\n        passwordHash: defaultPasswordHash,\n        role: 'shopper',\n        roles: ['shopper'],\n        status: 'active',\n        parentCode: demoMediatorCode,\n        isVerifiedByMediator: true,\n    });\n    await ShopperProfileModel.create({\n        userId: demoShopper._id,\n        defaultMediatorCode: demoMediatorCode,\n    });\n    await Promise.all([\n        ensureWallet(String(admin._id)),\n        ensureWallet(String(demoAgency._id)),\n        ensureWallet(String(demoMediator._id)),\n        ensureWallet(String(demoBrand._id)),\n        ensureWallet(String(demoShopper._id)),\n    ]);\n    // Create agencies + agency owner users\n    const agencies = [\n        { agencyCode: demoAgencyCode, ownerUserId: String(demoAgency._id), name: 'Demo Agency' },\n    ];\n    for (let i = 0; i < Math.max(2, Math.floor(opts.usersPerRole / 50)); i++) {\n        const agencyCode = `AGY_${faker.string.alpha({ length: 6, casing: 'upper' })}_${i}`;\n        const agencyName = `${faker.company.name()} Growth`;\n        const owner = await UserModel.create({\n            name: `${agencyName} Owner`,\n            mobile: makeIndianMobile(),\n            passwordHash: defaultPasswordHash,\n            role: 'agency',\n            roles: ['agency'],\n            status: 'active',\n            mediatorCode: agencyCode,\n            kycStatus: faker.helpers.arrayElement(['pending', 'verified']),\n        });\n        await AgencyModel.create({\n            name: agencyName,\n            agencyCode,\n            ownerUserId: owner._id,\n            status: 'active',\n        });\n        agencies.push({ agencyCode, ownerUserId: String(owner._id), name: agencyName });\n        // give agencies starting funds\n        await applyWalletCredit({\n            idempotencyKey: `seed-agency-fund-${agencyCode}`,\n            type: 'brand_deposit',\n            ownerUserId: String(owner._id),\n            amountPaise: faker.number.int({ min: 50_000_00, max: 500_000_00 }),\n            metadata: { seeded: true },\n        });\n    }\n    // Create brands + brand owner users\n    const brands = [\n        {\n            brandCode: demoBrandCode,\n            ownerUserId: String(demoBrand._id),\n            name: 'Demo Brand',\n            connectedAgencyCodes: [demoAgencyCode],\n        },\n    ];\n    for (let i = 0; i < Math.max(5, Math.floor(opts.usersPerRole / 25)); i++) {\n        const brandCode = `BRD_${faker.string.alpha({ length: 6, casing: 'upper' })}_${i}`;\n        const brandName = faker.company.name();\n        const owner = await UserModel.create({\n            name: `${brandName} Brand`,\n            mobile: makeIndianMobile(),\n            passwordHash: defaultPasswordHash,\n            role: 'brand',\n            roles: ['brand'],\n            status: 'active',\n            brandCode,\n        });\n        const connectedAgencyCodes = faker.helpers.arrayElements(agencies.map((a) => a.agencyCode), { min: 1, max: Math.min(5, agencies.length) });\n        await BrandModel.create({\n            name: brandName,\n            brandCode,\n            ownerUserId: owner._id,\n            status: 'active',\n            connectedAgencyCodes,\n        });\n        brands.push({\n            brandCode,\n            ownerUserId: String(owner._id),\n            name: brandName,\n            connectedAgencyCodes,\n        });\n        // give brands budget\n        await applyWalletCredit({\n            idempotencyKey: `seed-brand-fund-${brandCode}`,\n            type: 'brand_deposit',\n            ownerUserId: String(owner._id),\n            amountPaise: faker.number.int({ min: 1_000_000_00, max: 20_000_000_00 }),\n            metadata: { seeded: true },\n        });\n    }\n    // Create mediators\n    const mediators = [\n        { mediatorCode: demoMediatorCode, userId: String(demoMediator._id), parentAgencyCode: demoAgencyCode },\n    ];\n    for (let i = 0; i < opts.usersPerRole; i++) {\n        const parentAgency = faker.helpers.arrayElement(agencies);\n        const mediatorCode = `MED_${faker.string.alpha({ length: 7, casing: 'upper' })}_${i}`;\n        const user = await UserModel.create({\n            name: faker.person.fullName(),\n            mobile: makeIndianMobile(),\n            passwordHash: defaultPasswordHash,\n            role: 'mediator',\n            roles: ['mediator'],\n            status: faker.helpers.weightedArrayElement([\n                { weight: 90, value: 'active' },\n                { weight: 7, value: 'pending' },\n                { weight: 3, value: 'suspended' },\n            ]),\n            mediatorCode,\n            parentCode: parentAgency.agencyCode,\n            kycStatus: faker.helpers.arrayElement(['pending', 'verified', 'rejected']),\n        });\n        await MediatorProfileModel.create({\n            userId: user._id,\n            mediatorCode,\n            parentAgencyCode: parentAgency.agencyCode,\n            status: user.status,\n        });\n        mediators.push({\n            mediatorCode,\n            userId: String(user._id),\n            parentAgencyCode: parentAgency.agencyCode,\n        });\n        await applyWalletCredit({\n            idempotencyKey: `seed-mediator-fund-${mediatorCode}`,\n            type: 'commission_settle',\n            ownerUserId: String(user._id),\n            amountPaise: faker.number.int({ min: 0, max: 200_000_00 }),\n            metadata: { seeded: true },\n        });\n    }\n    // Create shoppers\n    const shoppers = [\n        { userId: String(demoShopper._id), name: 'Demo Buyer', mobile: '9000000004', mediatorCode: demoMediatorCode },\n    ];\n    for (let i = 0; i < opts.usersPerRole; i++) {\n        const mediator = faker.helpers.arrayElement(mediators);\n        const verified = faker.datatype.boolean(0.85);\n        const user = await UserModel.create({\n            name: faker.person.fullName(),\n            mobile: makeIndianMobile(),\n            passwordHash: defaultPasswordHash,\n            role: 'shopper',\n            roles: ['shopper'],\n            status: 'active',\n            parentCode: mediator.mediatorCode,\n            isVerifiedByMediator: verified,\n        });\n        await ShopperProfileModel.create({\n            userId: user._id,\n            defaultMediatorCode: mediator.mediatorCode,\n        });\n        shoppers.push({\n            userId: String(user._id),\n            name: String(user.name),\n            mobile: String(user.mobile),\n            mediatorCode: mediator.mediatorCode,\n        });\n        await applyWalletCredit({\n            idempotencyKey: `seed-shopper-fund-${user._id}`,\n            type: 'cashback_settle',\n            ownerUserId: String(user._id),\n            amountPaise: faker.number.int({ min: 0, max: 50_000_00 }),\n            metadata: { seeded: true },\n        });\n    }\n    // Create campaigns\n    const campaigns = [];\n    for (let i = 0; i < opts.campaigns; i++) {\n        const brand = faker.helpers.arrayElement(brands);\n        const allowedAgencyCodes = faker.helpers.arrayElements(brand.connectedAgencyCodes, {\n            min: 1,\n            max: Math.min(3, brand.connectedAgencyCodes.length),\n        });\n        const original = faker.number.int({ min: 999_00, max: 99_999_00 });\n        const discounted = Math.max(1, Math.floor(original * faker.number.float({ min: 0.4, max: 0.9 })));\n        const doc = await CampaignModel.create({\n            title: faker.commerce.productName(),\n            brandUserId: brand.ownerUserId,\n            brandName: brand.name,\n            platform: faker.helpers.arrayElement(['Amazon', 'Flipkart', 'Myntra']),\n            image: faker.image.url(),\n            productUrl: faker.internet.url(),\n            originalPricePaise: original,\n            pricePaise: discounted,\n            payoutPaise: faker.number.int({ min: 50_00, max: 5_000_00 }),\n            returnWindowDays: faker.number.int({ min: 7, max: 30 }),\n            totalSlots: faker.number.int({ min: 100, max: 10_000 }),\n            usedSlots: faker.number.int({ min: 0, max: 5000 }),\n            status: faker.helpers.weightedArrayElement([\n                { weight: 10, value: 'draft' },\n                { weight: 70, value: 'active' },\n                { weight: 10, value: 'paused' },\n                { weight: 10, value: 'completed' },\n            ]),\n            allowedAgencyCodes,\n            assignments: {},\n            dealType: faker.helpers.arrayElement(['Discount', 'Review', 'Rating']),\n        });\n        campaigns.push(doc);\n    }\n    // Create deals for mediators (only from active campaigns that their agency is allowed to access)\n    const activeCampaigns = campaigns.filter((c) => c.status === 'active');\n    for (const mediator of mediators) {\n        const accessible = activeCampaigns.filter((c) => (c.allowedAgencyCodes ?? []).includes(mediator.parentAgencyCode));\n        if (!accessible.length)\n            continue;\n        const chosen = faker.helpers.arrayElements(accessible, {\n            min: 0,\n            max: Math.min(opts.dealsPerMediator, accessible.length),\n        });\n        for (const c of chosen) {\n            // eslint-disable-next-line no-await-in-loop\n            await DealModel.updateOne({ campaignId: c._id, mediatorCode: mediator.mediatorCode, deletedAt: null }, {\n                $setOnInsert: {\n                    campaignId: c._id,\n                    mediatorCode: mediator.mediatorCode,\n                    title: c.title,\n                    description: 'Exclusive',\n                    image: c.image,\n                    productUrl: c.productUrl,\n                    platform: c.platform,\n                    brandName: c.brandName,\n                    dealType: c.dealType,\n                    originalPricePaise: c.originalPricePaise,\n                    pricePaise: c.pricePaise,\n                    commissionPaise: c.payoutPaise,\n                    category: faker.helpers.arrayElement(['Beauty', 'Grocery', 'Electronics', 'Fashion', 'General']),\n                    active: true,\n                },\n            }, { upsert: true });\n        }\n    }\n    // Create orders across workflow states\n    const dealIndex = await DealModel.find({ active: true, deletedAt: null })\n        .limit(50_000)\n        .lean();\n    const dealsByMediator = new Map();\n    for (const d of dealIndex) {\n        const arr = dealsByMediator.get(String(d.mediatorCode)) ?? [];\n        arr.push(d);\n        dealsByMediator.set(String(d.mediatorCode), arr);\n    }\n    const workflowStates = [\n        'REDIRECTED',\n        'ORDERED',\n        'PROOF_SUBMITTED',\n        'UNDER_REVIEW',\n        'APPROVED',\n        'REJECTED',\n        'COMPLETED',\n    ];\n    const ordersToCreate = Math.min(opts.orders, shoppers.length);\n    const createdOrders = [];\n    for (let i = 0; i < ordersToCreate; i++) {\n        const shopper = shoppers[i];\n        const mediatorDeals = dealsByMediator.get(shopper.mediatorCode) ?? [];\n        if (!mediatorDeals.length)\n            continue;\n        const deal = faker.helpers.arrayElement(mediatorDeals);\n        const campaign = activeCampaigns.find((c) => String(c._id) === String(deal.campaignId));\n        if (!campaign)\n            continue;\n        const workflowWeights = workflowStates.map((s) => ({\n            value: s,\n            weight: s === 'COMPLETED' ? 10 : s === 'REJECTED' ? 6 : 14,\n        }));\n        const workflowStatus = faker.helpers.weightedArrayElement(workflowWeights);\n        // eslint-disable-next-line no-await-in-loop\n        const order = await OrderModel.create({\n            userId: shopper.userId,\n            brandUserId: campaign.brandUserId,\n            items: [\n                {\n                    productId: faker.string.uuid(),\n                    title: String(deal.title),\n                    image: String(deal.image),\n                    priceAtPurchasePaise: Number(deal.pricePaise),\n                    commissionPaise: Number(deal.commissionPaise),\n                    campaignId: deal.campaignId,\n                    dealType: String(deal.dealType),\n                    quantity: 1,\n                    platform: String(deal.platform),\n                    brandName: String(deal.brandName),\n                },\n            ],\n            totalPaise: Number(deal.pricePaise),\n            workflowStatus,\n            status: workflowStatus === 'COMPLETED' ? 'Delivered' : 'Ordered',\n            paymentStatus: workflowStatus === 'COMPLETED' ? 'Paid' : 'Pending',\n            affiliateStatus: workflowStatus === 'REJECTED' ? 'Rejected' : 'Unchecked',\n            externalOrderId: `EXT_${faker.string.alphanumeric({ length: 10, casing: 'upper' })}_${i}`,\n            managerName: shopper.mediatorCode,\n            agencyName: '',\n            buyerName: shopper.name,\n            buyerMobile: shopper.mobile,\n            brandName: String(deal.brandName),\n            events: [{ type: 'SEEDED', at: new Date(), metadata: { seeded: true, workflowStatus } }],\n        });\n        createdOrders.push(order);\n    }\n    // Tickets\n    for (let i = 0; i < Math.min(opts.tickets, createdOrders.length); i++) {\n        const order = createdOrders[i];\n        // eslint-disable-next-line no-await-in-loop\n        const buyer = await UserModel.findById(order.userId).lean();\n        if (!buyer)\n            continue;\n        // eslint-disable-next-line no-await-in-loop\n        await TicketModel.create({\n            userId: buyer._id,\n            userName: String(buyer.name),\n            role: String(buyer.role),\n            orderId: String(order._id),\n            issueType: faker.helpers.arrayElement(['Payment', 'Order', 'Proof', 'Settlement', 'Account']),\n            description: faker.lorem.sentences({ min: 1, max: 3 }),\n            status: faker.helpers.arrayElement(['Open', 'Resolved', 'Rejected']),\n        });\n    }\n    // Payout requests for a subset of mediators\n    for (let i = 0; i < Math.min(opts.payouts, mediators.length); i++) {\n        const mediator = mediators[i];\n        const wallet = await ensureWallet(mediator.userId);\n        // eslint-disable-next-line no-await-in-loop\n        await PayoutModel.create({\n            beneficiaryUserId: mediator.userId,\n            walletId: wallet._id,\n            amountPaise: faker.number.int({ min: 500_00, max: 50_000_00 }),\n            status: faker.helpers.arrayElement(['requested', 'processing', 'paid', 'failed']),\n            requestedAt: faker.date.recent({ days: 30 }),\n        });\n    }\n    // eslint-disable-next-line no-console\n    console.log('Γ£à Large seed complete');\n    // eslint-disable-next-line no-console\n    console.log({\n        seed: opts.seed,\n        usersPerRole: opts.usersPerRole,\n        campaigns: opts.campaigns,\n        dealsPerMediator: opts.dealsPerMediator,\n        ordersCreated: createdOrders.length,\n        tickets: Math.min(opts.tickets, createdOrders.length),\n        payouts: Math.min(opts.payouts, mediators.length),\n        credentials: {\n            admin: { mobile: 'admin', password: DEFAULT_PASSWORD },\n            agency: { mobile: '9000000001', password: DEFAULT_PASSWORD, agencyCode: demoAgencyCode },\n            mediator: {\n                mobile: '9000000002',\n                password: DEFAULT_PASSWORD,\n                mediatorCode: demoMediatorCode,\n                parentAgencyCode: demoAgencyCode,\n            },\n            brand: { mobile: '9000000003', password: DEFAULT_PASSWORD, brandCode: demoBrandCode },\n            buyer: { mobile: '9000000004', password: DEFAULT_PASSWORD, parentMediatorCode: demoMediatorCode },\n        },\n    });\n}\nasync function main() {\n    await runLargeSeed();\n    await disconnectMongo();\n}\nfunction isDirectlyExecuted() {\n    // In ESM, detect \"node/tsx path/to/file\" execution.\n    // When imported (e.g. by backend/index.ts), we must NOT auto-run.\n    const entry = process.argv[1];\n    if (!entry)\n        return false;\n    return entry.replace(/\\\\/g, '/').endsWith('/backend/seeds/seed.ts') || entry.replace(/\\\\/g, '/').endsWith('/seeds/seed.ts');\n}\nif (isDirectlyExecuted()) {\n    main().catch((err) => {\n        // eslint-disable-next-line no-console\n        console.error('Seed failed:', err);\n        process.exitCode = 1;\n    });\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\services\\aiService.js","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_createInputError' is defined but never used.","line":45,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":45,"endColumn":27},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'no-await-in-loop').","line":315,"column":17,"severity":1,"nodeType":null,"fix":{"range":[13047,13091],"text":" "}},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'no-await-in-loop').","line":522,"column":17,"severity":1,"nodeType":null,"fix":{"range":[21931,21975],"text":" "}},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'no-await-in-loop').","line":1328,"column":25,"severity":1,"nodeType":null,"fix":{"range":[64481,64525],"text":" "}},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'no-await-in-loop').","line":1518,"column":21,"severity":1,"nodeType":null,"fix":{"range":[74336,74380],"text":" "}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_lastError' is assigned a value but never used.","line":1561,"column":21,"nodeType":"Identifier","messageId":"unusedVar","endLine":1561,"endColumn":31}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":4,"source":"import { GoogleGenAI, Type } from '@google/genai';\nimport sharp from 'sharp';\nimport { createWorker } from 'tesseract.js';\nconst GEMINI_MODEL_FALLBACKS = [\n    // Use fully-qualified model names as returned by `ai.models.list()`.\n    'models/gemini-2.5-flash',\n    'models/gemini-2.0-flash',\n    'models/gemini-2.0-flash-001',\n    'models/gemini-2.0-flash-exp',\n    'models/gemini-2.5-pro',\n];\nexport function isGeminiConfigured(env) {\n    return Boolean(env.GEMINI_API_KEY && String(env.GEMINI_API_KEY).trim());\n}\nfunction requireGeminiKey(env) {\n    if (env.AI_ENABLED === false) {\n        throw Object.assign(new Error('AI is disabled. Set AI_ENABLED=true to enable Gemini calls.'), {\n            statusCode: 503,\n        });\n    }\n    if (!env.GEMINI_API_KEY) {\n        throw Object.assign(new Error('Gemini is not configured. Set GEMINI_API_KEY on the backend.'), {\n            statusCode: 503,\n        });\n    }\n    return env.GEMINI_API_KEY;\n}\nfunction sanitizeAiError(err) {\n    if (!err)\n        return 'Unknown error';\n    if (err instanceof Error) {\n        // Avoid leaking stack traces or any accidental sensitive info.\n        return String(err.message || 'AI request failed').slice(0, 300);\n    }\n    return String(err).slice(0, 300);\n}\n/** Per-model timeout (15s). Prevents a single slow model from blocking the whole fallback chain. */\nconst PER_MODEL_TIMEOUT_MS = 15_000;\nfunction withModelTimeout(promise) {\n    return Promise.race([\n        promise,\n        new Promise((_, reject) => setTimeout(() => reject(new Error('Model response timed out')), PER_MODEL_TIMEOUT_MS)),\n    ]);\n}\nfunction _createInputError(message, statusCode = 400) {\n    return Object.assign(new Error(message), { statusCode });\n}\nfunction stripUnsafeContent(raw) {\n    return raw\n        .replace(/<[^>]*>/g, ' ') // HTML\n        .replace(/```[\\s\\S]*?```/g, ' ') // code blocks\n        .replace(/\\{[\\s\\S]*\\}/g, ' ') // JSON blobs\n        .replace(/(stack trace:|traceback:)[\\s\\S]*/gi, ' ') // stack traces\n        .replace(/[\\r\\n]+/g, ' ') // logs/newlines\n        .replace(/\\s{2,}/g, ' ')\n        .trim();\n}\n/**\n * Detect adversarial prompt injection attempts.\n * Returns `true` if the input contains suspicious patterns that try to override system instructions.\n */\nfunction containsPromptInjection(text) {\n    if (!text)\n        return false;\n    const lower = text.toLowerCase();\n    const patterns = [\n        /ignore\\s+(all\\s+)?(previous|prior|above|earlier)\\s+(instructions?|prompts?|rules?)/i,\n        /\\byou\\s+are\\s+now\\b/i,\n        /\\bsystem\\s*prompt\\b/i,\n        /\\bforget\\s+(your|all|everything)\\b/i,\n        /\\bdo\\s+not\\s+follow\\s+(any|your|the)\\s+(rules?|instructions?)\\b/i,\n        /\\boverride\\s+(all|your|the|system)\\b/i,\n        /\\bact\\s+as\\s+(if|though)\\s+you\\s+(are|were)\\b/i,\n        /\\bjailbreak\\b/i,\n        /\\bDAN\\s*mode\\b/i,\n    ];\n    return patterns.some((p) => p.test(lower));\n}\nfunction estimateTokensFromText(text) {\n    if (!text)\n        return 0;\n    return Math.ceil(text.length / 4);\n}\nfunction estimateTokensFromImage(base64) {\n    if (!base64)\n        return 0;\n    // Gemini processes images as fixed 768├ù768 tiles.\n    // Most images fit in 1ΓÇô4 tiles ΓåÆ ~258ΓÇô1030 tokens regardless of file size.\n    // The base64 length only tells us the file size, NOT the token count.\n    // A conservative estimate: 1 tile (258 tokens) per 500KB of raw image data.\n    const rawBytes = Math.ceil(base64.length * 3 / 4);\n    const tilesEstimate = Math.max(1, Math.ceil(rawBytes / 500_000));\n    return tilesEstimate * 258;\n}\nfunction sanitizeUserMessage(env, message) {\n    if (!message)\n        return '';\n    if (message.length > env.AI_MAX_INPUT_CHARS) {\n        message = message.slice(0, env.AI_MAX_INPUT_CHARS);\n    }\n    // Reject prompt injection attempts before further processing.\n    if (containsPromptInjection(message)) {\n        return 'How can I help you today?';\n    }\n    const cleaned = stripUnsafeContent(message);\n    if (!cleaned)\n        return '';\n    if (cleaned.length > env.AI_MAX_INPUT_CHARS) {\n        return cleaned.slice(0, env.AI_MAX_INPUT_CHARS);\n    }\n    return cleaned;\n}\nfunction sanitizeHistory(env, history) {\n    const items = Array.isArray(history) ? history : [];\n    const maxHistoryChars = Math.min(env.AI_MAX_INPUT_CHARS, 600);\n    const trimmed = items.slice(-env.AI_MAX_HISTORY_MESSAGES).map((item) => ({\n        role: item.role,\n        content: sanitizeUserMessage(env, item.content).slice(0, maxHistoryChars),\n    }));\n    const older = items.slice(0, Math.max(0, items.length - trimmed.length));\n    const summary = older.length\n        ? older\n            .map((m) => stripUnsafeContent(m.content))\n            .join(' | ')\n            .slice(0, env.AI_HISTORY_SUMMARY_CHARS)\n        : '';\n    return { trimmed, summary };\n}\nexport async function checkGeminiApiKey(env) {\n    const apiKey = requireGeminiKey(env);\n    const ai = new GoogleGenAI({ apiKey });\n    for (const model of GEMINI_MODEL_FALLBACKS) {\n        try {\n            // A tiny request whose only purpose is to validate connectivity + auth.\n            await withModelTimeout(ai.models.generateContent({\n                model,\n                contents: 'ping',\n            }));\n            return { ok: true, model };\n        }\n        catch (err) {\n            // Try the next model; return last error if all fail.\n            const error = sanitizeAiError(err);\n            if (model === GEMINI_MODEL_FALLBACKS[GEMINI_MODEL_FALLBACKS.length - 1]) {\n                return { ok: false, model, error };\n            }\n        }\n    }\n    return { ok: false, model: GEMINI_MODEL_FALLBACKS[0], error: 'AI request failed' };\n}\nfunction safeJsonParse(raw) {\n    if (!raw)\n        return null;\n    try {\n        return JSON.parse(raw);\n    }\n    catch {\n        return null;\n    }\n}\nfunction extractJsonObject(raw) {\n    if (!raw)\n        return null;\n    const trimmed = raw.trim();\n    if (!trimmed)\n        return null;\n    const codeBlockMatch = trimmed.match(/```(?:json)?\\s*([\\s\\S]*?)\\s*```/i);\n    if (codeBlockMatch?.[1]) {\n        const inner = codeBlockMatch[1].trim();\n        if (inner.startsWith('{') && inner.endsWith('}'))\n            return inner;\n    }\n    const start = trimmed.indexOf('{');\n    const end = trimmed.lastIndexOf('}');\n    if (start === -1 || end === -1 || end <= start)\n        return null;\n    return trimmed.slice(start, end + 1).trim();\n}\nfunction parseModelResponse(raw) {\n    if (!raw)\n        return null;\n    const direct = safeJsonParse(raw);\n    if (direct)\n        return direct;\n    const extracted = extractJsonObject(raw);\n    if (!extracted)\n        return null;\n    return safeJsonParse(extracted);\n}\nfunction sanitizeModelText(raw) {\n    if (!raw)\n        return '';\n    let cleaned = String(raw);\n    cleaned = cleaned.replace(/```[\\s\\S]*?```/g, ' ');\n    cleaned = cleaned.replace(/here is the json requested:?/gi, ' ');\n    // Only strip \"json\" when it's a standalone formatting artifact (e.g., model returning \"json {}\")\n    // Avoid stripping it from legitimate sentences like \"I can export JSON files\".\n    cleaned = cleaned.replace(/^\\s*json\\s*$/gim, ' ');\n    cleaned = cleaned.replace(/\\s{2,}/g, ' ').trim();\n    return cleaned;\n}\nexport async function generateChatUiResponse(env, payload) {\n    const apiKey = requireGeminiKey(env);\n    const ai = new GoogleGenAI({ apiKey });\n    const clampText = (value, max) => (value.length > max ? value.slice(0, max) : value);\n    let imageForPrompt = payload.image;\n    if (imageForPrompt && imageForPrompt.length > env.AI_MAX_IMAGE_CHARS) {\n        imageForPrompt = undefined;\n    }\n    const sanitizedMessage = sanitizeUserMessage(env, payload.message || '');\n    const { trimmed: historyMessages, summary: historySummary } = sanitizeHistory(env, payload.history);\n    const products = Array.isArray(payload.products) ? payload.products : [];\n    const dealContextRaw = products\n        .slice(0, 10)\n        .map((p) => {\n        const id = p.id ?? 'unknown';\n        const title = p.title ?? 'Untitled';\n        const price = typeof p.price === 'number' ? p.price : 0;\n        const originalPrice = typeof p.originalPrice === 'number' ? p.originalPrice : price;\n        const platform = p.platform ?? 'Unknown';\n        return `[ID: ${id}] ${title} - Price: Γé╣${price} (MRP: Γé╣${originalPrice}) on ${platform}`;\n    })\n        .join('\\n');\n    let dealContext = clampText(dealContextRaw, 800);\n    let ordersSnippet = clampText(JSON.stringify((payload.orders || []).slice(0, 3)), Math.min(env.AI_MAX_INPUT_CHARS, 600));\n    let ticketsSnippet = clampText(JSON.stringify((payload.tickets || []).slice(0, 2)), Math.min(env.AI_MAX_INPUT_CHARS, 600));\n    let historyMessagesForPrompt = historyMessages;\n    const buildSystemPrompt = (deals, orders, tickets, summary, hasImage) => `\r\nYou are 'BUZZMA', a world-class AI shopping strategist for ${payload.userName || 'Guest'}.\r\n\r\nCONTEXT:\r\n- DEALS: ${deals}\r\n- RECENT ORDERS: ${orders}\r\n- TICKETS: ${tickets}\r\n${summary ? `- SUMMARY: ${summary}` : ''}\r\n\r\nBEHAVIOR:\r\n1. Be concise and friendly.\r\n2. If user mentions \"shoes\", \"deals\", \"offers\", identify matching IDs and put them in 'recommendedProductIds'.\r\n3. Classify intent: 'search_deals', 'check_order_status', 'check_ticket_status', 'navigation', 'greeting', or 'unknown'.\r\n4. For navigation, use: 'home', 'explore', 'orders', 'profile'.\r\n5. Use **bold** for key info like **Γé╣599** or **Delivered**.\r\n6. Always respond in JSON format with responseText, intent, and optional fields.\r\n${hasImage\n        ? `7. IMAGE ANALYSIS (HIGHEST PRIORITY):\r\n   - The user has uploaded an image. IGNORE the 'RECENT ORDERS' list for identification purposes.\r\n   - EXTRACT the Order ID exactly as appearing in the image (e.g., Amazon '404-1234567...', Flipkart 'OD123...', Myntra, etc.).\r\n   - EXTRACT the Final Order Amount/Total.\r\n   - STRICTLY IGNORE any \"system\" IDs (e.g., random UUIDs, IDs starting with SYS/MOBO, or single/double digit numbers).\r\n   - If you see an Order ID in the image, your response text MUST begin with: \"Found Order ID: <ID>\".\r\n   - If you cannot clearly read an Order ID, say \"Could not read Order ID from image\".`\n        : ''}\r\n`;\n    let systemPrompt = buildSystemPrompt(dealContext, ordersSnippet, ticketsSnippet, historySummary, !!imageForPrompt);\n    let historyText = clampText(historyMessagesForPrompt.map((m) => `[${m.role}] ${m.content}`).join('\\n'), Math.min(env.AI_MAX_INPUT_CHARS, 1200));\n    const safeMessage = sanitizedMessage || 'Hello';\n    let estimatedTokens = estimateTokensFromText(systemPrompt) +\n        estimateTokensFromText(safeMessage) +\n        estimateTokensFromText(historyText) +\n        estimateTokensFromImage(imageForPrompt || '');\n    if (estimatedTokens > env.AI_MAX_ESTIMATED_TOKENS) {\n        historyMessagesForPrompt = historyMessages.slice(-2);\n        historyText = clampText(historyMessagesForPrompt.map((m) => `[${m.role}] ${m.content}`).join('\\n'), Math.min(env.AI_MAX_INPUT_CHARS, 600));\n        dealContext = clampText(dealContextRaw, 300);\n        ordersSnippet = '';\n        ticketsSnippet = '';\n        const reducedSummary = historySummary ? clampText(historySummary, 120) : '';\n        systemPrompt = buildSystemPrompt(dealContext, ordersSnippet, ticketsSnippet, reducedSummary, !!imageForPrompt);\n        estimatedTokens =\n            estimateTokensFromText(systemPrompt) +\n                estimateTokensFromText(safeMessage) +\n                estimateTokensFromText(historyText) +\n                estimateTokensFromImage(imageForPrompt || '');\n    }\n    if (estimatedTokens > env.AI_MAX_ESTIMATED_TOKENS) {\n        historyMessagesForPrompt = [];\n        historyText = '';\n        dealContext = '';\n        ordersSnippet = '';\n        ticketsSnippet = '';\n        systemPrompt = buildSystemPrompt('', '', '', '', !!imageForPrompt);\n        estimatedTokens =\n            estimateTokensFromText(systemPrompt) +\n                estimateTokensFromText(safeMessage) +\n                estimateTokensFromText(historyText) +\n                estimateTokensFromImage(imageForPrompt || '');\n    }\n    if (estimatedTokens > env.AI_MAX_ESTIMATED_TOKENS && imageForPrompt) {\n        imageForPrompt = undefined;\n        estimatedTokens =\n            estimateTokensFromText(systemPrompt) +\n                estimateTokensFromText(safeMessage) +\n                estimateTokensFromText(historyText);\n    }\n    const contents = imageForPrompt\n        ? [\n            {\n                inlineData: {\n                    mimeType: 'image/jpeg',\n                    data: imageForPrompt.split(',')[1] ?? imageForPrompt,\n                },\n            },\n            { text: safeMessage || 'Analyze this image.' },\n        ]\n        : [\n            ...(historyMessagesForPrompt.length\n                ? historyMessagesForPrompt.map((m) => ({ text: `[${m.role}] ${m.content}` }))\n                : []),\n            { text: safeMessage },\n        ];\n    try {\n        let lastError = null;\n        for (const model of GEMINI_MODEL_FALLBACKS) {\n            try {\n                // eslint-disable-next-line no-await-in-loop\n                const response = await withModelTimeout(ai.models.generateContent({\n                    model,\n                    contents,\n                    config: {\n                        systemInstruction: systemPrompt,\n                        maxOutputTokens: env.AI_MAX_OUTPUT_TOKENS_CHAT,\n                        responseMimeType: 'application/json',\n                        responseSchema: {\n                            type: Type.OBJECT,\n                            properties: {\n                                responseText: { type: Type.STRING },\n                                intent: {\n                                    type: Type.STRING,\n                                    enum: [\n                                        'greeting',\n                                        'search_deals',\n                                        'check_order_status',\n                                        'check_ticket_status',\n                                        'navigation',\n                                        'unknown',\n                                    ],\n                                },\n                                navigateTo: { type: Type.STRING, enum: ['home', 'explore', 'orders', 'profile'] },\n                                recommendedProductIds: { type: Type.ARRAY, items: { type: Type.STRING } },\n                            },\n                            required: ['responseText', 'intent'],\n                        },\n                    },\n                }));\n                const parsed = parseModelResponse(response.text) ?? {\n                    responseText: sanitizeModelText(response.text) ||\n                        \"I'm here to help with deals, orders, or tickets. What would you like?\",\n                    intent: 'unknown',\n                };\n                const recommendedIds = Array.isArray(parsed.recommendedProductIds)\n                    ? parsed.recommendedProductIds\n                    : [];\n                let recommendedProducts = recommendedIds.length\n                    ? products.filter((p) => p.id && recommendedIds.includes(String(p.id)))\n                    : [];\n                if (parsed.intent === 'search_deals' && recommendedProducts.length === 0 && products.length) {\n                    recommendedProducts = products.slice(0, 5);\n                }\n                console.info('Gemini chat usage estimate', {\n                    model,\n                    estimatedTokens,\n                });\n                return {\n                    text: parsed.responseText,\n                    intent: parsed.intent ?? 'unknown',\n                    navigateTo: parsed.navigateTo,\n                    ...(recommendedProducts.length\n                        ? { uiType: 'product_card', data: recommendedProducts }\n                        : {}),\n                };\n            }\n            catch (innerError) {\n                lastError = innerError;\n                continue;\n            }\n        }\n        throw lastError ?? new Error('Gemini request failed');\n    }\n    catch (error) {\n        // Fallback response if AI fails\n        console.error('Gemini API error:', error);\n        return {\n            text: `Hi ${payload.userName}! I'm experiencing some technical difficulties right now, but I'm here to help. Could you try rephrasing your question?`,\n            intent: 'unknown',\n        };\n    }\n}\n/**\n * Detect MIME type from a base64 data-URL or raw base64 magic bytes.\n * Returns a safe default of 'image/jpeg' when detection fails.\n */\nfunction detectImageMimeType(base64) {\n    // data:image/png;base64,...\n    const dataMatch = base64.match(/^data:(image\\/[a-z+]+);base64,/i);\n    if (dataMatch)\n        return dataMatch[1].toLowerCase();\n    // Check raw base64 magic bytes\n    const raw = base64.slice(0, 16);\n    if (raw.startsWith('iVBOR'))\n        return 'image/png';\n    if (raw.startsWith('/9j/') || raw.startsWith('/9J/'))\n        return 'image/jpeg';\n    if (raw.startsWith('R0lGOD'))\n        return 'image/gif';\n    if (raw.startsWith('UklGR'))\n        return 'image/webp';\n    return 'image/jpeg';\n}\n/**\n * OCR-based proof verification fallback.\n * When Gemini is unavailable, run Tesseract on the proof image and do deterministic matching\n * against the expected order ID and amount.\n */\nasync function verifyProofWithOcr(imageBase64, expectedOrderId, expectedAmount) {\n    try {\n        const rawData = imageBase64.includes(',') ? imageBase64.split(',')[1] : imageBase64;\n        const imgBuffer = Buffer.from(rawData, 'base64');\n        // Preprocess with Sharp for better OCR accuracy\n        let processedBuffer;\n        try {\n            processedBuffer = await sharp(imgBuffer)\n                .greyscale()\n                .normalize()\n                .sharpen()\n                .toBuffer();\n        }\n        catch {\n            processedBuffer = imgBuffer;\n        }\n        const worker = await createWorker('eng');\n        const { data } = await worker.recognize(processedBuffer);\n        await worker.terminate();\n        const ocrText = (data.text || '').trim();\n        if (!ocrText || ocrText.length < 5) {\n            return {\n                orderIdMatch: false,\n                amountMatch: false,\n                confidenceScore: 15,\n                discrepancyNote: 'OCR could not read text from the image. Please verify manually.',\n            };\n        }\n        // Normalize OCR digit confusion\n        const normalized = ocrText\n            .replace(/[Oo]/g, (m) => (/[A-Za-z]/.test(m) ? m : '0'))\n            .replace(/[Il|]/g, '1')\n            .replace(/[Ss]/g, (m) => (/[A-Za-z]/.test(m) ? m : '5'));\n        // Check if expected order ID appears in OCR text\n        const orderIdNormalized = expectedOrderId.replace(/[\\s\\-]/g, '');\n        const ocrNormalized = normalized.replace(/[\\s\\-]/g, '');\n        const orderIdMatch = ocrNormalized.toUpperCase().includes(orderIdNormalized.toUpperCase());\n        // Check if expected amount appears in OCR text (allow ┬▒1 tolerance for OCR errors)\n        const amountPatterns = [\n            String(expectedAmount),\n            expectedAmount.toFixed(2),\n            // Indian comma format: 1,23,456\n            expectedAmount.toLocaleString('en-IN'),\n        ];\n        const amountMatch = amountPatterns.some((p) => ocrText.includes(p));\n        let confidenceScore = 30; // base OCR confidence\n        if (orderIdMatch)\n            confidenceScore += 30;\n        if (amountMatch)\n            confidenceScore += 25;\n        if (orderIdMatch && amountMatch)\n            confidenceScore = Math.min(confidenceScore + 10, 85);\n        const detectedNotes = [];\n        if (!orderIdMatch)\n            detectedNotes.push(`Order ID \"${expectedOrderId}\" not found in screenshot.`);\n        if (!amountMatch)\n            detectedNotes.push(`Amount Γé╣${expectedAmount} not found in screenshot.`);\n        if (orderIdMatch && amountMatch)\n            detectedNotes.push('Both order ID and amount matched via OCR.');\n        return {\n            orderIdMatch,\n            amountMatch,\n            confidenceScore,\n            discrepancyNote: detectedNotes.join(' ') || 'OCR fallback verification complete.',\n        };\n    }\n    catch (err) {\n        console.error('OCR proof verification error:', err);\n        return {\n            orderIdMatch: false,\n            amountMatch: false,\n            confidenceScore: 0,\n            discrepancyNote: 'Auto verification unavailable. Please verify manually.',\n        };\n    }\n}\nexport async function verifyProofWithAi(env, payload) {\n    const geminiAvailable = isGeminiConfigured(env);\n    if (payload.imageBase64.length > env.AI_MAX_IMAGE_CHARS) {\n        return {\n            orderIdMatch: false,\n            amountMatch: false,\n            confidenceScore: 0,\n            discrepancyNote: 'Auto verification unavailable. Please verify manually.',\n        };\n    }\n    const estimatedTokens = estimateTokensFromImage(payload.imageBase64) +\n        estimateTokensFromText(payload.expectedOrderId) +\n        estimateTokensFromText(String(payload.expectedAmount));\n    if (estimatedTokens > env.AI_MAX_ESTIMATED_TOKENS) {\n        return {\n            orderIdMatch: false,\n            amountMatch: false,\n            confidenceScore: 0,\n            discrepancyNote: 'Auto verification unavailable. Please verify manually.',\n        };\n    }\n    // If Gemini is not available, fall back to OCR-based verification.\n    if (!geminiAvailable) {\n        return verifyProofWithOcr(payload.imageBase64, payload.expectedOrderId, payload.expectedAmount);\n    }\n    const apiKey = env.GEMINI_API_KEY;\n    const ai = new GoogleGenAI({ apiKey });\n    const mimeType = detectImageMimeType(payload.imageBase64);\n    try {\n        let lastError = null;\n        for (const model of GEMINI_MODEL_FALLBACKS) {\n            try {\n                // eslint-disable-next-line no-await-in-loop\n                const response = await withModelTimeout(ai.models.generateContent({\n                    model,\n                    contents: [\n                        {\n                            inlineData: {\n                                mimeType,\n                                data: payload.imageBase64.split(',')[1] ?? payload.imageBase64,\n                            },\n                        },\n                        {\n                            text: [\n                                `PROOF VERIFICATION TASK ΓÇö GOD-LEVEL ACCURACY REQUIRED`,\n                                ``,\n                                `You must verify whether this screenshot proves a purchase with:`,\n                                `  Expected Order ID: ${payload.expectedOrderId}`,\n                                `  Expected Amount: Γé╣${payload.expectedAmount}`,\n                                ``,\n                                `RULES:`,\n                                `1. Extract the ACTUAL order ID visible in the screenshot. Look for labels like \"Order ID\", \"Order No\", \"Order #\", or platform-specific patterns (Amazon: 3-7-7 digits, Flipkart: OD..., Myntra: MYN..., Meesho: MSH..., etc.)`,\n                                `2. IGNORE tracking IDs, shipment numbers, AWB numbers, transaction IDs, UTR numbers, UPI references, and invoice numbers ΓÇö these are NOT order IDs.`,\n                                `3. Extract the FINAL amount paid (Grand Total / Amount Paid / You Paid / Order Total). Ignore MRP, item price, or subtotal if a different total is shown.`,\n                                `4. For amount matching: Γé╣${payload.expectedAmount} should match even if displayed as Γé╣${payload.expectedAmount}.00 or with Indian comma formatting (e.g., Γé╣1,23,456). Allow ┬▒Γé╣1 tolerance for rounding.`,\n                                `5. For order ID matching: Compare after removing spaces, hyphens, and case differences. Partial matches count as mismatches.`,\n                                `6. Set confidenceScore 0-100: 90+ if both clearly visible and matched, 60-89 if partially matched or slightly unclear, below 60 if mismatched or unreadable.`,\n                                `7. Always fill detectedOrderId and detectedAmount with what you actually see in the image, even if they don't match the expected values.`,\n                            ].join('\\n'),\n                        },\n                    ],\n                    config: {\n                        maxOutputTokens: env.AI_MAX_OUTPUT_TOKENS_PROOF,\n                        responseMimeType: 'application/json',\n                        responseSchema: {\n                            type: Type.OBJECT,\n                            properties: {\n                                orderIdMatch: { type: Type.BOOLEAN },\n                                amountMatch: { type: Type.BOOLEAN },\n                                confidenceScore: { type: Type.INTEGER },\n                                detectedOrderId: { type: Type.STRING },\n                                detectedAmount: { type: Type.NUMBER },\n                                discrepancyNote: { type: Type.STRING },\n                            },\n                            required: ['orderIdMatch', 'amountMatch', 'confidenceScore'],\n                        },\n                    },\n                }));\n                const parsed = safeJsonParse(response.text);\n                if (!parsed) {\n                    throw new Error('Failed to parse AI verification response');\n                }\n                // Clamp confidenceScore to 0-100\n                parsed.confidenceScore = Math.max(0, Math.min(100, parsed.confidenceScore ?? 0));\n                console.info('Gemini proof usage estimate', { model, estimatedTokens });\n                return parsed;\n            }\n            catch (innerError) {\n                lastError = innerError;\n                continue;\n            }\n        }\n        throw lastError ?? new Error('Gemini proof verification failed');\n    }\n    catch (error) {\n        console.error('Gemini proof verification error:', error);\n        // Fall back to OCR when Gemini fails at runtime.\n        return verifyProofWithOcr(payload.imageBase64, payload.expectedOrderId, payload.expectedAmount);\n    }\n}\nexport async function extractOrderDetailsWithAi(env, payload) {\n    const geminiAvailable = isGeminiConfigured(env);\n    const ai = geminiAvailable ? new GoogleGenAI({ apiKey: env.GEMINI_API_KEY }) : null;\n    if (payload.imageBase64.length > env.AI_MAX_IMAGE_CHARS) {\n        return {\n            orderId: null,\n            amount: null,\n            confidenceScore: 0,\n            notes: 'Image too large. Please upload a smaller screenshot.',\n        };\n    }\n    // NOTE: Token estimation is NOT used as a gate here.\n    // Tesseract.js is local and free ΓÇö no token limit applies.\n    // For Gemini, the API enforces its own token limits.\n    // The AI_MAX_IMAGE_CHARS check above is the sole size gate.\n    try {\n        let _lastError = null;\n        // ΓöÇΓöÇΓöÇ REGEX PATTERNS ΓöÇΓöÇΓöÇ //\n        const ORDER_KEYWORD_RE = /order\\s*(id|no\\.?|number|#|:)/i;\n        const EXCLUDED_LINE_RE = /\\b(tracking\\s*(id|no|number|#)|shipment\\s*(id|no|number|#)|awb|invoice\\s*(id|no|number|#)|transaction\\s*(id|no|number|#)|utr|upi\\s*(ref|id)|ref(erence)?\\s*(id|no|number|#))\\b/i;\n        const ORDER_LABEL_PATTERN = 'order\\\\s*(?:id|no\\\\.?|number|#)\\\\s*[:\\\\-#]?\\\\s*([A-Z0-9\\\\-_/]{4,40})';\n        // ΓöÇΓöÇ Platform-specific order ID patterns ΓöÇΓöÇ\n        const AMAZON_ORDER_PATTERN = '\\\\b\\\\d{3}[\\\\-\\\\s]?\\\\d{7}[\\\\-\\\\s]?\\\\d{7}\\\\b';\n        const FLIPKART_ORDER_PATTERN = '\\\\b[O0][Dd]\\\\d{10,}\\\\b';\n        const MYNTRA_ORDER_PATTERN = '\\\\b(?:MYN|MNT|ORD|PP)[\\\\-\\\\s]?\\\\d{6,}\\\\b';\n        const MEESHO_ORDER_PATTERN = '\\\\b(?:MSH|MEESH[O0])[\\\\-\\\\s]?\\\\d{6,}\\\\b';\n        const AJIO_ORDER_PATTERN = '\\\\bFN[\\\\-\\\\s]?\\\\d{6,}\\\\b';\n        const JIO_ORDER_PATTERN = '\\\\b(?:JIO|OM)[\\\\-\\\\s]?\\\\d{8,}\\\\b';\n        const NYKAA_ORDER_PATTERN = '\\\\bNYK[\\\\-\\\\s]?\\\\d{6,}\\\\b';\n        const TATA_ORDER_PATTERN = '\\\\b(?:TCL|TATA)[\\\\-\\\\s]?\\\\d{6,}\\\\b';\n        const SNAPDEAL_ORDER_PATTERN = '\\\\b(?:SD)[\\\\-\\\\s]?\\\\d{8,}\\\\b';\n        const BIGBASKET_ORDER_PATTERN = '\\\\b(?:BB)[\\\\-\\\\s]?\\\\d{8,}\\\\b';\n        const ONMG_ORDER_PATTERN = '\\\\b(?:1MG)[\\\\-\\\\s]?\\\\d{6,}\\\\b';\n        const CROMA_ORDER_PATTERN = '\\\\b(?:CRM|CROMA)[\\\\-\\\\s]?\\\\d{6,}\\\\b';\n        const PURPLLE_ORDER_PATTERN = '\\\\b(?:PUR|PURP)[\\\\-\\\\s]?\\\\d{6,}\\\\b';\n        const AMAZON_SPACED_PATTERN = '(?:\\\\d[\\\\s\\\\-\\\\.]{0,2}){17}';\n        const GENERIC_ID_PATTERN = '\\\\b[A-Z][A-Z0-9\\\\-]{7,}\\\\b';\n        // ΓöÇΓöÇ Amount patterns (Γé╣, Rs, INR, bare) ΓöÇΓöÇ\n        const AMOUNT_LABEL_RE = /(grand\\s*total|amount\\s*paid|paid\\s*amount|you\\s*paid|order\\s*total|final\\s*total|total\\s*amount|net\\s*amount|payable|item\\s*total|subtotal|sub\\s*total|bag\\s*total|cart\\s*value|deal\\s*price|offer\\s*price|sale\\s*price|final\\s*price|price|your\\s*price|estimated\\s*total|total)/i;\n        // Priority labels that indicate the FINAL price paid (not MRP)\n        const FINAL_AMOUNT_LABEL_RE = /(grand\\s*total|amount\\s*paid|paid\\s*amount|you\\s*paid|order\\s*total|final\\s*total|total\\s*amount|net\\s*amount|payable|estimated\\s*total)/i;\n        const AMOUNT_VALUE_PATTERN = 'Γé╣?\\\\s*([0-9][0-9,]*(?:\\\\.[0-9]{1,2})?)';\n        // Indian currency: Γé╣, Rs, Rs., INR, plus Tesseract variants (Rs, R5, R$)\n        const INR_VALUE_PATTERN = '(?:Γé╣|(?:rs|r[5s$])\\\\.?|inr)\\\\s*\\\\.?\\\\s*([0-9][0-9,]*(?:\\\\.[0-9]{1,2})?)';\n        const BARE_AMOUNT_PATTERN = '\\\\b([0-9]{2,8}(?:\\\\.[0-9]{1,2})?)\\\\b';\n        // ΓöÇΓöÇ Compiled regexes ΓöÇΓöÇ\n        const ORDER_LABEL_RE = new RegExp(ORDER_LABEL_PATTERN, 'i');\n        const AMAZON_ORDER_RE = new RegExp(AMAZON_ORDER_PATTERN, 'i');\n        const AMAZON_ORDER_GLOBAL_RE = new RegExp(AMAZON_ORDER_PATTERN, 'gi');\n        const FLIPKART_ORDER_RE = new RegExp(FLIPKART_ORDER_PATTERN, 'i');\n        const FLIPKART_ORDER_GLOBAL_RE = new RegExp(FLIPKART_ORDER_PATTERN, 'gi');\n        const MYNTRA_ORDER_RE = new RegExp(MYNTRA_ORDER_PATTERN, 'i');\n        const MYNTRA_ORDER_GLOBAL_RE = new RegExp(MYNTRA_ORDER_PATTERN, 'gi');\n        const MEESHO_ORDER_RE = new RegExp(MEESHO_ORDER_PATTERN, 'i');\n        const MEESHO_ORDER_GLOBAL_RE = new RegExp(MEESHO_ORDER_PATTERN, 'gi');\n        const AJIO_ORDER_RE = new RegExp(AJIO_ORDER_PATTERN, 'i');\n        const AJIO_ORDER_GLOBAL_RE = new RegExp(AJIO_ORDER_PATTERN, 'gi');\n        const JIO_ORDER_RE = new RegExp(JIO_ORDER_PATTERN, 'i');\n        const NYKAA_ORDER_RE = new RegExp(NYKAA_ORDER_PATTERN, 'i');\n        const TATA_ORDER_RE = new RegExp(TATA_ORDER_PATTERN, 'i');\n        const SNAPDEAL_ORDER_RE = new RegExp(SNAPDEAL_ORDER_PATTERN, 'i');\n        const BIGBASKET_ORDER_RE = new RegExp(BIGBASKET_ORDER_PATTERN, 'i');\n        const ONMG_ORDER_RE = new RegExp(ONMG_ORDER_PATTERN, 'i');\n        const CROMA_ORDER_RE = new RegExp(CROMA_ORDER_PATTERN, 'i');\n        const PURPLLE_ORDER_RE = new RegExp(PURPLLE_ORDER_PATTERN, 'i');\n        const AMAZON_SPACED_GLOBAL_RE = new RegExp(AMAZON_SPACED_PATTERN, 'g');\n        const GENERIC_ID_RE = new RegExp(GENERIC_ID_PATTERN, 'i');\n        const AMOUNT_VALUE_GLOBAL_RE = new RegExp(AMOUNT_VALUE_PATTERN, 'g');\n        const INR_VALUE_GLOBAL_RE = new RegExp(INR_VALUE_PATTERN, 'gi');\n        const BARE_AMOUNT_GLOBAL_RE = new RegExp(BARE_AMOUNT_PATTERN, 'g');\n        const sanitizeOrderId = (value) => {\n            if (typeof value !== 'string')\n                return null;\n            const raw = value.trim().replace(/[\\s]+/g, '');\n            if (!raw)\n                return null;\n            const upper = raw.toUpperCase();\n            if (upper.startsWith('E2E-') || upper.startsWith('SYS') || upper.includes('MOBO') || upper.includes('BUZZMA')) {\n                return null;\n            }\n            if (/^[a-f0-9]{24}$/i.test(raw))\n                return null; // Mongo ObjectId\n            if (/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(raw))\n                return null; // UUID\n            if (raw.length < 4 || raw.length > 64)\n                return null;\n            // Must contain at least one digit to be a valid order ID\n            if (!/\\d/.test(raw))\n                return null;\n            return raw;\n        };\n        const normalizeOcrText = (value) => typeof value === 'string'\n            ? value\n                .replace(/\\r\\n/g, '\\n')\n                .replace(/\\r/g, '\\n')\n                // Fix common OCR ligature/encoding artifacts\n                .replace(/∩¼ü/g, 'fi')\n                .replace(/∩¼é/g, 'fl')\n                .replace(/\\u00a0/g, ' ') // non-breaking space\n            : '';\n        const normalizeLine = (line) => line.trim();\n        const hasOrderKeyword = (line) => ORDER_KEYWORD_RE.test(line);\n        const hasExcludedKeyword = (line) => EXCLUDED_LINE_RE.test(line);\n        const normalizeCandidate = (value) => value.replace(/[\\s:]/g, '').replace(/[\\.,]$/, '').trim().toUpperCase();\n        const scoreOrderId = (value, context) => {\n            const upper = value.toUpperCase().replace(/\\s/g, '');\n            let score = 0;\n            if (context.hasKeyword)\n                score += 4;\n            if (upper.includes('-'))\n                score += 2;\n            if (/\\d/.test(upper) && /[A-Z]/.test(upper))\n                score += 2;\n            if (/^\\d{10,20}$/.test(upper))\n                score += 1;\n            // Platform-specific bonus scoring\n            if (new RegExp(`^${AMAZON_ORDER_PATTERN}$`).test(upper))\n                score += 10;\n            if (/^OD\\d{10,}$/.test(upper))\n                score += 8;\n            if (new RegExp(`^${MYNTRA_ORDER_PATTERN}$`).test(upper))\n                score += 8;\n            if (new RegExp(`^${MEESHO_ORDER_PATTERN}$`).test(upper))\n                score += 8;\n            if (new RegExp(`^${AJIO_ORDER_PATTERN}$`).test(upper))\n                score += 8;\n            if (new RegExp(`^${JIO_ORDER_PATTERN}$`).test(upper))\n                score += 8;\n            if (new RegExp(`^${SNAPDEAL_ORDER_PATTERN}$`).test(upper))\n                score += 8;\n            if (new RegExp(`^${BIGBASKET_ORDER_PATTERN}$`).test(upper))\n                score += 8;\n            if (context.occursInText)\n                score += 1;\n            return score;\n        };\n        /** Map OCR-confused characters to digits (for Amazon 17-digit extraction). */\n        const normalizeDigits = (value) => value\n            .replace(/[Oo]/g, '0')\n            .replace(/[Il|]/g, '1')\n            .replace(/S/g, '5')\n            .replace(/B/g, '8')\n            .replace(/Z/g, '2')\n            .replace(/[ΓÇöΓÇô]/g, '-') // em-dash / en-dash ΓåÆ hyphen\n            .replace(/\\./g, '-'); // period sometimes confused with dash\n        const coerceAmazonOrderId = (value) => {\n            // Try direct match first (already well-formed)\n            const directMatch = value.match(/(\\d{3})-(\\d{7})-(\\d{7})/);\n            if (directMatch)\n                return directMatch[0];\n            // Try with normalized digits\n            const normalized = normalizeDigits(value);\n            const digitsOnly = normalized.replace(/[^0-9]/g, '');\n            if (digitsOnly.length === 17) {\n                return `${digitsOnly.slice(0, 3)}-${digitsOnly.slice(3, 10)}-${digitsOnly.slice(10)}`;\n            }\n            // If 18-19 digits, try trimming leading/trailing zeros from OCR noise\n            if (digitsOnly.length >= 18 && digitsOnly.length <= 20) {\n                for (let start = 0; start <= digitsOnly.length - 17; start++) {\n                    const candidate = digitsOnly.slice(start, start + 17);\n                    const formatted = `${candidate.slice(0, 3)}-${candidate.slice(3, 10)}-${candidate.slice(10)}`;\n                    if (/^\\d{3}-\\d{7}-\\d{7}$/.test(formatted))\n                        return formatted;\n                }\n            }\n            return null;\n        };\n        const parseAmountString = (raw) => {\n            if (!raw)\n                return null;\n            // Indian format: 1,23,456.00 ΓåÆ remove commas. Standard: 123,456.00 ΓåÆ remove commas.\n            const cleaned = raw.replace(/,/g, '');\n            const value = Number(cleaned);\n            if (!Number.isFinite(value) || value <= 0)\n                return null;\n            // Round to 2 decimals to avoid floating point noise\n            return Math.round(value * 100) / 100;\n        };\n        const extractAmounts = (text) => {\n            const lines = text.split('\\n').map(normalizeLine).filter(Boolean);\n            const finalAmounts = []; // \"grand total\", \"amount paid\", etc.\n            const labeledAmounts = []; // \"total\", \"price\", \"subtotal\", etc.\n            for (let i = 0; i < lines.length; i += 1) {\n                const line = lines[i];\n                const isFinalLabel = FINAL_AMOUNT_LABEL_RE.test(line);\n                const isAnyLabel = AMOUNT_LABEL_RE.test(line);\n                if (!isAnyLabel)\n                    continue;\n                // Look for amounts on the same line\n                const matches = line.matchAll(AMOUNT_VALUE_GLOBAL_RE);\n                for (const match of matches) {\n                    const value = parseAmountString(match[1]);\n                    if (!value)\n                        continue;\n                    if (isFinalLabel)\n                        finalAmounts.push(value);\n                    else\n                        labeledAmounts.push(value);\n                }\n                // Also try INR-prefixed patterns on the same line\n                const inrMatches = line.matchAll(new RegExp(INR_VALUE_PATTERN, 'gi'));\n                for (const match of inrMatches) {\n                    const value = parseAmountString(match[1]);\n                    if (!value)\n                        continue;\n                    if (isFinalLabel)\n                        finalAmounts.push(value);\n                    else\n                        labeledAmounts.push(value);\n                }\n                // If no amount on this line, check the next line (label on one line, value on next)\n                if (!finalAmounts.length && !labeledAmounts.length && lines[i + 1]) {\n                    const nextLineMatches = lines[i + 1].matchAll(AMOUNT_VALUE_GLOBAL_RE);\n                    for (const match of nextLineMatches) {\n                        const value = parseAmountString(match[1]);\n                        if (!value)\n                            continue;\n                        if (isFinalLabel)\n                            finalAmounts.push(value);\n                        else\n                            labeledAmounts.push(value);\n                    }\n                }\n            }\n            // Priority: \"final\" labels (amount paid, grand total) > general labels (total, price)\n            if (finalAmounts.length)\n                return Math.max(...finalAmounts);\n            if (labeledAmounts.length)\n                return Math.max(...labeledAmounts);\n            // Fallback: any INR-prefixed value in the entire text\n            const inrMatches = text.matchAll(INR_VALUE_GLOBAL_RE);\n            const inrValues = [];\n            for (const match of inrMatches) {\n                const value = parseAmountString(match[1]);\n                if (value)\n                    inrValues.push(value);\n            }\n            if (inrValues.length)\n                return Math.max(...inrValues);\n            // Last resort: bare numbers that look like prices (Γé╣10 ΓÇô Γé╣9,99,999)\n            const bareMatches = text.matchAll(BARE_AMOUNT_GLOBAL_RE);\n            const bareValues = [];\n            for (const match of bareMatches) {\n                const value = parseAmountString(match[1]);\n                if (!value)\n                    continue;\n                if (value < 1 || value > 9_999_999)\n                    continue;\n                // Skip values that look like dates, years, phone numbers, pin codes\n                if (/^\\d{4}$/.test(match[1]) && value >= 1900 && value <= 2100)\n                    continue;\n                if (/^\\d{6}$/.test(match[1]) && value >= 100000 && value <= 999999)\n                    continue; // 6-digit pincode\n                if (/^\\d{10}$/.test(match[1]))\n                    continue; // phone number\n                bareValues.push(value);\n            }\n            if (bareValues.length)\n                return Math.max(...bareValues);\n            return null;\n        };\n        /** Extract order date from OCR text. */\n        const extractOrderDate = (text) => {\n            const lines = text.split('\\n').map(normalizeLine).filter(Boolean);\n            // Look for lines containing date-related keywords\n            const dateKeywordRe = /\\b(order\\s*(placed|date)|placed\\s*on|date|ordered\\s*on|purchase\\s*date|bought\\s*on)\\b/i;\n            // Date patterns: \"7 February 2026\", \"07-02-2026\", \"07/02/2026\", \"Feb 7, 2026\", \"2026-02-07\"\n            const datePatterns = [\n                /(\\d{1,2})\\s+(January|February|March|April|May|June|July|August|September|October|November|December)\\s+(\\d{4})/i,\n                /(January|February|March|April|May|June|July|August|September|October|November|December)\\s+(\\d{1,2}),?\\s+(\\d{4})/i,\n                /(\\d{1,2})[-\\/](\\d{1,2})[-\\/](\\d{4})/,\n                /(\\d{4})[-\\/](\\d{1,2})[-\\/](\\d{1,2})/,\n                /(\\d{1,2})\\s+(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[a-z]*\\s+(\\d{4})/i,\n                /(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[a-z]*\\s+(\\d{1,2}),?\\s+(\\d{4})/i,\n            ];\n            // First try lines with date keywords\n            for (const line of lines) {\n                if (!dateKeywordRe.test(line))\n                    continue;\n                for (const pattern of datePatterns) {\n                    const match = line.match(pattern);\n                    if (match)\n                        return match[0].trim();\n                }\n            }\n            // Fallback: look for any date-like pattern in the entire text\n            for (const pattern of datePatterns) {\n                const match = text.match(pattern);\n                if (match)\n                    return match[0].trim();\n            }\n            return null;\n        };\n        /** Extract \"Sold by\" merchant name from OCR text. */\n        const extractSoldBy = (text) => {\n            const lines = text.split('\\n').map(normalizeLine).filter(Boolean);\n            const soldByRe = /\\b(sold\\s*by|seller|shipped\\s*by|fulfilled\\s*by|dispatched\\s*by)\\s*[:\\-]?\\s*/i;\n            for (let i = 0; i < lines.length; i++) {\n                const line = lines[i];\n                const match = line.match(soldByRe);\n                if (match) {\n                    // Extract the text after \"Sold by:\"\n                    const afterKeyword = line.slice(match.index + match[0].length).trim();\n                    if (afterKeyword && afterKeyword.length >= 2 && afterKeyword.length <= 120) {\n                        // Clean up common OCR artifacts\n                        const cleaned = afterKeyword\n                            .replace(/[^A-Za-z0-9\\s&.,\\-'()]/g, '')\n                            .replace(/\\s{2,}/g, ' ')\n                            .trim();\n                        if (cleaned.length >= 2)\n                            return cleaned;\n                    }\n                    // Check next line if this line only has the label\n                    const nextLine = lines[i + 1];\n                    if (nextLine && nextLine.length >= 2 && nextLine.length <= 120) {\n                        const cleaned = nextLine\n                            .replace(/[^A-Za-z0-9\\s&.,\\-'()]/g, '')\n                            .replace(/\\s{2,}/g, ' ')\n                            .trim();\n                        if (cleaned.length >= 2)\n                            return cleaned;\n                    }\n                }\n            }\n            return null;\n        };\n        /** Extract product name from OCR text. */\n        const extractProductName = (text) => {\n            const lines = text.split('\\n').map(normalizeLine).filter(Boolean);\n            // Look for common product name patterns in e-commerce screenshots\n            // Typically the product name is the longest descriptive line near the top\n            // or near price/amount information\n            const excludePatterns = [\n                /^(order|tracking|invoice|payment|ship|deliver|cancel|return|refund|subtotal|total|grand|amount|paid|you paid|item|qty|quantity)/i,\n                /^\\d+$/,\n                /^[Γé╣$Γé¼]\\s*\\d/,\n                /^(rs|inr)\\b/i,\n                /^(sold|seller|fulfilled|dispatched)\\s*by/i,\n                /^(arriving|expected|estimated)\\s*(on|by|date|delivery)/i,\n                /^(your|my)\\s*(account|order|address)/i,\n                /^(ship\\s*to|deliver\\s*to|billing)/i,\n                /^\\d{1,2}\\s*(january|february|march|april|may|june|july|august|september|october|november|december)/i,\n            ];\n            // Heuristic: find lines that look like product titles\n            // Product names tend to be: 20-200 chars, contain mixed case or title case,\n            // contain brand/product words, are near image or price references\n            const candidates = [];\n            for (let i = 0; i < lines.length; i++) {\n                const line = lines[i];\n                if (line.length < 10 || line.length > 250)\n                    continue;\n                if (excludePatterns.some(p => p.test(line)))\n                    continue;\n                let score = 0;\n                // Longer descriptive lines score higher (likely product names)\n                if (line.length >= 20 && line.length <= 150)\n                    score += 3;\n                if (line.length >= 30)\n                    score += 1;\n                // Contains common product keywords\n                if (/\\b(for|with|pack|set|kit|box|ml|gm|kg|ltr|pcs|combo)\\b/i.test(line))\n                    score += 3;\n                // Contains pipe or dash separators (common in e-commerce titles)\n                if (/[|]/.test(line))\n                    score += 2;\n                // Mixed case (product titles tend to be mixed case)\n                if (/[A-Z]/.test(line) && /[a-z]/.test(line))\n                    score += 1;\n                // Near price/amount lines\n                if (i > 0 && /Γé╣|rs\\.?|inr|price/i.test(lines[i - 1] || ''))\n                    score += 1;\n                if (i < lines.length - 1 && /Γé╣|rs\\.?|inr|price/i.test(lines[i + 1] || ''))\n                    score += 2;\n                // Near \"sold by\" lines\n                if (i > 0 && /sold\\s*by/i.test(lines[i - 1] || ''))\n                    score += 1;\n                if (i < lines.length - 1 && /sold\\s*by/i.test(lines[i + 1] || ''))\n                    score += 2;\n                if (score >= 3) {\n                    candidates.push({ name: line.replace(/\\s{2,}/g, ' ').trim(), score });\n                }\n            }\n            if (candidates.length === 0)\n                return null;\n            candidates.sort((a, b) => b.score - a.score);\n            return candidates[0].name;\n        };\n        /** Fix common OCR letter/digit confusion for platform prefixes. */\n        const fixOcrPrefixes = (line) => line\n            // Flipkart: 0D / 0d ΓåÆ OD (zero mistaken for O, any case)\n            .replace(/\\b0[Dd](\\d{10,})\\b/g, 'OD$1')\n            // Myntra: 0RD ΓåÆ ORD\n            .replace(/\\b0RD(\\d{6,})\\b/gi, 'ORD$1')\n            // Meesho: MEESH0 ΓåÆ MEESHO\n            .replace(/\\bMEESH0/gi, 'MEESHO')\n            // Snapdeal: S0 ΓåÆ SD (if followed by digits)\n            .replace(/\\bS0(\\d{8,})\\b/g, 'SD$1')\n            // BigBasket: 88 ΓåÆ BB (OCR reads B as 8)\n            .replace(/\\b88(\\d{8,})\\b/g, 'BB$1');\n        const extractOrderId = (text) => {\n            const lines = text.split('\\n').map(normalizeLine).filter(Boolean);\n            const candidates = [];\n            const pushCandidate = (value, hasKeyword) => {\n                const sanitized = sanitizeOrderId(value);\n                if (!sanitized)\n                    return;\n                const occursInText = text.toLowerCase().includes(sanitized.toLowerCase());\n                const score = scoreOrderId(sanitized, { hasKeyword, occursInText });\n                candidates.push({ value: sanitized, score });\n            };\n            for (let i = 0; i < lines.length; i += 1) {\n                const line = fixOcrPrefixes(lines[i]);\n                if (hasExcludedKeyword(line))\n                    continue;\n                const hasKeyword = hasOrderKeyword(line);\n                if (hasKeyword) {\n                    const labeled = line.match(ORDER_LABEL_RE);\n                    if (labeled?.[1]) {\n                        const coerced = coerceAmazonOrderId(labeled[1]);\n                        pushCandidate(coerced ?? labeled[1], true);\n                    }\n                    const spaced = line.match(new RegExp(AMAZON_SPACED_PATTERN));\n                    if (spaced?.[0]) {\n                        const coerced = coerceAmazonOrderId(spaced[0]);\n                        if (coerced)\n                            pushCandidate(coerced, true);\n                    }\n                    const nextLine = lines[i + 1];\n                    if (nextLine) {\n                        const amazonNext = nextLine.match(AMAZON_ORDER_RE);\n                        if (amazonNext?.[0]) {\n                            const coerced = coerceAmazonOrderId(amazonNext[0]);\n                            pushCandidate(coerced ?? amazonNext[0], true);\n                        }\n                        const spacedNext = nextLine.match(new RegExp(AMAZON_SPACED_PATTERN));\n                        if (spacedNext?.[0]) {\n                            const coerced = coerceAmazonOrderId(spacedNext[0]);\n                            if (coerced)\n                                pushCandidate(coerced, true);\n                        }\n                        const genericNext = nextLine.match(GENERIC_ID_RE);\n                        if (genericNext?.[0])\n                            pushCandidate(genericNext[0], true);\n                    }\n                }\n                const amazon = line.match(AMAZON_ORDER_RE);\n                if (amazon?.[0]) {\n                    const coerced = coerceAmazonOrderId(amazon[0]);\n                    pushCandidate(coerced ?? amazon[0], hasKeyword);\n                }\n                // All platform-specific patterns (applied to each line)\n                const platformRegexes = [\n                    [FLIPKART_ORDER_RE, false],\n                    [MYNTRA_ORDER_RE, false],\n                    [MEESHO_ORDER_RE, false],\n                    [AJIO_ORDER_RE, false],\n                    [JIO_ORDER_RE, false],\n                    [NYKAA_ORDER_RE, false],\n                    [TATA_ORDER_RE, false],\n                    [SNAPDEAL_ORDER_RE, false],\n                    [BIGBASKET_ORDER_RE, false],\n                    [ONMG_ORDER_RE, false],\n                    [CROMA_ORDER_RE, false],\n                    [PURPLLE_ORDER_RE, false],\n                ];\n                for (const [re] of platformRegexes) {\n                    const m = line.match(re);\n                    if (m?.[0]) {\n                        // Normalize Flipkart prefix to uppercase OD\n                        let val = m[0];\n                        if (/^[0o][Dd]/i.test(val))\n                            val = 'OD' + val.slice(2);\n                        pushCandidate(val, hasKeyword);\n                    }\n                }\n                if (hasKeyword) {\n                    const generic = line.match(GENERIC_ID_RE);\n                    if (generic?.[0])\n                        pushCandidate(generic[0], true);\n                }\n            }\n            // ΓöÇΓöÇ Global scan (full text) with OCR prefix fixes ΓöÇΓöÇ\n            const fixedText = fixOcrPrefixes(text);\n            const globalPlatformRegexes = [\n                AMAZON_ORDER_GLOBAL_RE,\n                FLIPKART_ORDER_GLOBAL_RE,\n                MYNTRA_ORDER_GLOBAL_RE,\n                MEESHO_ORDER_GLOBAL_RE,\n                AJIO_ORDER_GLOBAL_RE,\n            ];\n            for (const re of globalPlatformRegexes) {\n                re.lastIndex = 0; // Reset global regex state\n                for (const m of fixedText.matchAll(re)) {\n                    let val = m[0];\n                    if (/^[0o][Dd]/i.test(val))\n                        val = 'OD' + val.slice(2);\n                    pushCandidate(val, false);\n                }\n            }\n            const spacedAmazon = Array.from(text.matchAll(AMAZON_SPACED_GLOBAL_RE)).map((m) => m[0]);\n            for (const chunk of spacedAmazon) {\n                const coerced = coerceAmazonOrderId(chunk);\n                if (coerced)\n                    pushCandidate(coerced, false);\n            }\n            const globalDigits = normalizeDigits(text).match(/\\d{17}/g) || [];\n            for (const digits of globalDigits) {\n                if (digits.length === 17) {\n                    pushCandidate(`${digits.slice(0, 3)}-${digits.slice(3, 10)}-${digits.slice(10)}`, false);\n                }\n            }\n            const unique = Array.from(new Map(candidates.map((c) => [normalizeCandidate(c.value), c])).values());\n            const sorted = unique.sort((a, b) => b.score - a.score || b.value.length - a.value.length);\n            return sorted[0]?.value || null;\n        };\n        const strictOcrPrompt = [\n            'You are a strict OCR engine.',\n            'Return ONLY the exact visible text from the image.',\n            'Do NOT summarize.',\n            'Do NOT infer.',\n            'Do NOT fix spelling.',\n            'Do NOT add or remove words.',\n            'Preserve line breaks and spacing.',\n        ].join('\\n');\n        const parseDataUrl = (dataUrl) => {\n            if (!dataUrl.includes(',')) {\n                return { mimeType: 'image/jpeg', data: dataUrl };\n            }\n            const [meta, data] = dataUrl.split(',', 2);\n            const match = meta.match(/data:([^;]+);base64/i);\n            return { mimeType: match?.[1] || 'image/jpeg', data: data || dataUrl };\n        };\n        const getImageBuffer = (base64) => {\n            const parsed = parseDataUrl(base64);\n            return Buffer.from(parsed.data, 'base64');\n        };\n        /**\n         * Check if a buffer starts with known image magic bytes.\n         * Prevents Sharp from crashing on garbage / corrupt / too-small data.\n         */\n        const isRecognizedImageBuffer = (buf) => {\n            if (buf.length < 4)\n                return false;\n            // JPEG: FF D8 FF\n            if (buf[0] === 0xFF && buf[1] === 0xD8 && buf[2] === 0xFF)\n                return true;\n            // PNG: 89 50 4E 47\n            if (buf[0] === 0x89 && buf[1] === 0x50 && buf[2] === 0x4E && buf[3] === 0x47)\n                return true;\n            // WebP: RIFF....WEBP\n            if (buf.length >= 12 && buf.toString('ascii', 0, 4) === 'RIFF' && buf.toString('ascii', 8, 12) === 'WEBP')\n                return true;\n            // GIF: GIF87a / GIF89a\n            if (buf.toString('ascii', 0, 3) === 'GIF')\n                return true;\n            // BMP: BM\n            if (buf[0] === 0x42 && buf[1] === 0x4D)\n                return true;\n            // TIFF: II (little-endian) or MM (big-endian)\n            if ((buf[0] === 0x49 && buf[1] === 0x49) || (buf[0] === 0x4D && buf[1] === 0x4D))\n                return true;\n            // AVIF / HEIF: ....ftyp\n            if (buf.length >= 8 && buf.toString('ascii', 4, 8) === 'ftyp')\n                return true;\n            return false;\n        };\n        const preprocessForOcr = async (base64, crop) => {\n            try {\n                const rawBuf = getImageBuffer(base64);\n                if (!isRecognizedImageBuffer(rawBuf)) {\n                    return base64; // Not a valid image ΓÇö skip Sharp processing\n                }\n                const input = sharp(rawBuf);\n                const metadata = await input.metadata();\n                const imgWidth = metadata.width ?? 0;\n                const imgHeight = metadata.height ?? 0;\n                let pipeline = input;\n                if (crop && imgWidth > 0 && imgHeight > 0) {\n                    const left = Math.max(0, Math.floor(imgWidth * (crop.left ?? 0)));\n                    const top = Math.max(0, Math.floor(imgHeight * (crop.top ?? 0)));\n                    const cw = Math.max(1, Math.min(imgWidth - left, Math.floor(imgWidth * (crop.width ?? 1))));\n                    const ch = Math.max(1, Math.min(imgHeight - top, Math.floor(imgHeight * (crop.height ?? 1))));\n                    pipeline = pipeline.extract({ left, top, width: cw, height: ch });\n                }\n                const processed = await pipeline\n                    // Upscale to help OCR with small fonts; avoid stripping info by keeping aspect ratio.\n                    .resize({ width: 2400, withoutEnlargement: false })\n                    .grayscale()\n                    .normalize()\n                    .sharpen()\n                    .jpeg({ quality: 90 })\n                    .toBuffer();\n                return `data:image/jpeg;base64,${processed.toString('base64')}`;\n            }\n            catch (err) {\n                console.warn('OCR preprocessing failed, using original image.', err);\n                return base64;\n            }\n        };\n        const extractTextOnly = async (model, imageBase64) => {\n            const parsed = parseDataUrl(imageBase64);\n            const response = await withModelTimeout(ai.models.generateContent({\n                model,\n                contents: [\n                    {\n                        inlineData: {\n                            mimeType: parsed.mimeType,\n                            data: parsed.data,\n                        },\n                    },\n                    { text: strictOcrPrompt },\n                ],\n                config: {\n                    temperature: 0,\n                    maxOutputTokens: Math.min(env.AI_MAX_OUTPUT_TOKENS_EXTRACT, 512),\n                    responseMimeType: 'text/plain',\n                },\n            }));\n            return normalizeOcrText(response.text || '');\n        };\n        const runDeterministicExtraction = (text) => {\n            const orderId = extractOrderId(text);\n            const amount = extractAmounts(text);\n            const orderDate = extractOrderDate(text);\n            const soldBy = extractSoldBy(text);\n            const productName = extractProductName(text);\n            const notes = [];\n            if (orderId)\n                notes.push('Deterministic order ID extracted.');\n            if (amount)\n                notes.push('Deterministic amount extracted.');\n            if (orderDate)\n                notes.push('Order date extracted.');\n            if (soldBy)\n                notes.push('Seller info extracted.');\n            if (productName)\n                notes.push('Product name extracted.');\n            return { orderId, amount, orderDate, soldBy, productName, notes };\n        };\n        /** Tesseract.js fallback: local OCR that works without any external API. */\n        const runTesseractOcr = async (imageBase64) => {\n            let worker = null;\n            try {\n                const buf = getImageBuffer(imageBase64);\n                if (!isRecognizedImageBuffer(buf)) {\n                    return ''; // Not a valid image ΓÇö skip Tesseract entirely\n                }\n                // Enhance the image for better Tesseract accuracy\n                const enhanced = await sharp(buf)\n                    .resize({ width: 2400, withoutEnlargement: false })\n                    .grayscale()\n                    .normalize()\n                    .sharpen({ sigma: 1.5 })\n                    .linear(1.2, -20) // Increase contrast\n                    .jpeg({ quality: 95 })\n                    .toBuffer();\n                worker = await createWorker('eng');\n                // Try default PSM first (automatic), then PSM 6 (uniform block of text)\n                const { data } = await worker.recognize(enhanced);\n                let text = normalizeOcrText(data.text || '');\n                // If default PSM yielded poor results, try PSM 6 (assumes a uniform block of text)\n                if (!text || text.length < 20) {\n                    await worker.setParameters({ tessedit_pageseg_mode: '6' });\n                    const { data: data6 } = await worker.recognize(enhanced);\n                    const text6 = normalizeOcrText(data6.text || '');\n                    if (text6.length > text.length)\n                        text = text6;\n                }\n                return text;\n            }\n            catch (err) {\n                console.warn('Tesseract OCR failed:', err);\n                return '';\n            }\n            finally {\n                // Always terminate the worker to prevent resource leaks.\n                try {\n                    await worker?.terminate();\n                }\n                catch { /* ignore cleanup errors */ }\n            }\n        };\n        const refineWithAi = async (model, ocrText, deterministic) => {\n            if (!ai)\n                return null;\n            const response = await withModelTimeout(ai.models.generateContent({\n                model,\n                contents: [\n                    {\n                        text: [\n                            'TASK: EXTRACT E-COMMERCE ORDER DETAILS FROM OCR TEXT.',\n                            'PRIORITY: GOD-LEVEL ACCURACY REQUIRED.',\n                            '1. EXTRACT the Order ID exactly as it appears (Amazon 404-..., Flipkart OD..., Myntra, Jio, etc.).',\n                            '2. EXTRACT the Final Order Amount (Grand Total / Amount Paid / You Paid ΓÇö NOT item price or subtotal).',\n                            '3. EXTRACT the Order Date (when the order was placed).',\n                            '4. EXTRACT \"Sold by\" / Seller name.',\n                            '5. EXTRACT the Product Name / Item title.',\n                            '6. IGNORE ambiguous single/double digit numbers.',\n                            '7. IGNORE system UUIDs or IDs that look like \"SYS-...\" or internal codes.',\n                            '8. If a DETERMINISTIC value is provided and looks correct, confirm it.',\n                            '9. If OCR text is messy but contains a likely Order ID, EXTRACT IT. Do not return null if a partial match exists.',\n                            `OCR_TEXT (Start):\\n${ocrText}\\n(End OCR_TEXT)`,\n                            `DETERMINISTIC_ORDER_ID: ${deterministic.orderId ?? 'null'}`,\n                            `DETERMINISTIC_AMOUNT: ${deterministic.amount ?? 'null'}`,\n                            `DETERMINISTIC_ORDER_DATE: ${deterministic.orderDate ?? 'null'}`,\n                            `DETERMINISTIC_SOLD_BY: ${deterministic.soldBy ?? 'null'}`,\n                            `DETERMINISTIC_PRODUCT_NAME: ${deterministic.productName ?? 'null'}`,\n                            'Return JSON with suggestedOrderId, suggestedAmount, suggestedOrderDate, suggestedSoldBy, suggestedProductName, confidenceScore (0-100), and notes.',\n                        ].join('\\n'),\n                    },\n                ],\n                config: {\n                    temperature: 0,\n                    maxOutputTokens: Math.min(env.AI_MAX_OUTPUT_TOKENS_EXTRACT, 512),\n                    responseMimeType: 'application/json',\n                    responseSchema: {\n                        type: Type.OBJECT,\n                        properties: {\n                            suggestedOrderId: { type: Type.STRING },\n                            suggestedAmount: { type: Type.NUMBER },\n                            suggestedOrderDate: { type: Type.STRING },\n                            suggestedSoldBy: { type: Type.STRING },\n                            suggestedProductName: { type: Type.STRING },\n                            confidenceScore: { type: Type.INTEGER },\n                            notes: { type: Type.STRING },\n                        },\n                        required: ['confidenceScore'],\n                    },\n                },\n            }));\n            return safeJsonParse(response.text) ?? null;\n        };\n        const runOcrPass = async (imageBase64, label) => {\n            // Try Gemini OCR first (if available)\n            if (ai) {\n                let text = '';\n                for (const model of GEMINI_MODEL_FALLBACKS) {\n                    try {\n                        // eslint-disable-next-line no-await-in-loop\n                        text = await extractTextOnly(model, imageBase64);\n                        if (text) {\n                            console.log('Order extract OCR pass', { label, model, length: text.length });\n                            return text;\n                        }\n                    }\n                    catch (innerError) {\n                        _lastError = innerError;\n                        continue;\n                    }\n                }\n            }\n            // Fallback: Tesseract.js local OCR (works without Gemini API key)\n            const tesseractText = await runTesseractOcr(imageBase64);\n            if (tesseractText) {\n                console.log('Order extract OCR pass (Tesseract)', { label, length: tesseractText.length });\n            }\n            return tesseractText;\n        };\n        // ΓöÇΓöÇ Build OCR variants: phone (vertical) + desktop (horizontal) crops ΓöÇΓöÇ\n        // Detect if image is landscape (desktop/laptop) or portrait (phone)\n        let isLandscape = false;\n        try {\n            const orientBuf = getImageBuffer(payload.imageBase64);\n            if (isRecognizedImageBuffer(orientBuf)) {\n                const meta = await sharp(orientBuf).metadata();\n                isLandscape = (meta.width ?? 0) > (meta.height ?? 0);\n            }\n        }\n        catch { /* ignore ΓÇö default to portrait */ }\n        const allOcrVariants = [\n            { label: 'original', image: payload.imageBase64 },\n            { label: 'enhanced', image: await preprocessForOcr(payload.imageBase64) },\n        ];\n        if (isLandscape) {\n            // Desktop/laptop: order info is often in the center or right portion\n            allOcrVariants.push({ label: 'center-60', image: await preprocessForOcr(payload.imageBase64, { left: 0.2, width: 0.6 }) }, { label: 'right-50', image: await preprocessForOcr(payload.imageBase64, { left: 0.5, width: 0.5 }) }, { label: 'left-50', image: await preprocessForOcr(payload.imageBase64, { left: 0, width: 0.5 }) }, { label: 'center-top-half', image: await preprocessForOcr(payload.imageBase64, { left: 0.15, width: 0.7, top: 0, height: 0.55 }) }, { label: 'center-bottom-half', image: await preprocessForOcr(payload.imageBase64, { left: 0.15, width: 0.7, top: 0.4, height: 0.6 }) });\n        }\n        else {\n            // Phone/portrait: order info is vertically distributed\n            allOcrVariants.push({ label: 'top-55', image: await preprocessForOcr(payload.imageBase64, { top: 0, height: 0.55 }) }, { label: 'top-35', image: await preprocessForOcr(payload.imageBase64, { top: 0, height: 0.35 }) }, { label: 'middle-50', image: await preprocessForOcr(payload.imageBase64, { top: 0.2, height: 0.5 }) }, { label: 'bottom-50', image: await preprocessForOcr(payload.imageBase64, { top: 0.45, height: 0.55 }) });\n        }\n        // When using Tesseract (no Gemini), limit variants ΓÇö but try more than before\n        const ocrVariants = ai ? allOcrVariants : allOcrVariants.slice(0, 5);\n        let ocrText = '';\n        let ocrLabel = 'none';\n        let deterministic = {\n            orderId: null,\n            amount: null,\n            orderDate: null,\n            soldBy: null,\n            productName: null,\n            notes: [],\n        };\n        let bestScore = 0;\n        // Accumulate results across OCR passes ΓÇö one crop may find the ID, another the amount\n        let accumulatedOrderId = null;\n        let accumulatedAmount = null;\n        let accumulatedOrderDate = null;\n        let accumulatedSoldBy = null;\n        let accumulatedProductName = null;\n        const allOcrTexts = [];\n        if (env.AI_DEBUG_OCR) {\n            const parsed = parseDataUrl(payload.imageBase64);\n            console.log('Order extract input', {\n                mimeType: parsed.mimeType,\n                imageChars: payload.imageBase64.length,\n            });\n        }\n        for (const variant of ocrVariants) {\n            const candidateText = await runOcrPass(variant.image, variant.label);\n            if (!candidateText)\n                continue;\n            allOcrTexts.push(candidateText);\n            const candidateDeterministic = runDeterministicExtraction(candidateText);\n            // Accumulate best-so-far results across all passes\n            if (candidateDeterministic.orderId && !accumulatedOrderId) {\n                accumulatedOrderId = candidateDeterministic.orderId;\n            }\n            if (candidateDeterministic.amount && !accumulatedAmount) {\n                accumulatedAmount = candidateDeterministic.amount;\n            }\n            if (candidateDeterministic.orderDate && !accumulatedOrderDate) {\n                accumulatedOrderDate = candidateDeterministic.orderDate;\n            }\n            if (candidateDeterministic.soldBy && !accumulatedSoldBy) {\n                accumulatedSoldBy = candidateDeterministic.soldBy;\n            }\n            if (candidateDeterministic.productName && !accumulatedProductName) {\n                accumulatedProductName = candidateDeterministic.productName;\n            }\n            const score = (candidateDeterministic.orderId ? 1 : 0) + (candidateDeterministic.amount ? 1 : 0);\n            if (score > bestScore) {\n                bestScore = score;\n                ocrText = candidateText;\n                ocrLabel = variant.label;\n                deterministic = candidateDeterministic;\n            }\n            // Early exit if we have both from the same pass\n            if (score === 2)\n                break;\n            // Also exit early if accumulated results from different passes give us both\n            if (accumulatedOrderId && accumulatedAmount)\n                break;\n        }\n        // If individual passes found different pieces, merge them\n        if (!deterministic.orderId && accumulatedOrderId) {\n            deterministic.orderId = accumulatedOrderId;\n            deterministic.notes.push('Order ID from alternate crop.');\n        }\n        if (!deterministic.amount && accumulatedAmount) {\n            deterministic.amount = accumulatedAmount;\n            deterministic.notes.push('Amount from alternate crop.');\n        }\n        if (!deterministic.orderDate && accumulatedOrderDate) {\n            deterministic.orderDate = accumulatedOrderDate;\n            deterministic.notes.push('Order date from alternate crop.');\n        }\n        if (!deterministic.soldBy && accumulatedSoldBy) {\n            deterministic.soldBy = accumulatedSoldBy;\n            deterministic.notes.push('Seller info from alternate crop.');\n        }\n        if (!deterministic.productName && accumulatedProductName) {\n            deterministic.productName = accumulatedProductName;\n            deterministic.notes.push('Product name from alternate crop.');\n        }\n        // Last resort: concatenate all OCR text and run deterministic extraction on the combined text\n        if (!deterministic.orderId || !deterministic.amount) {\n            const combinedText = allOcrTexts.join('\\n');\n            if (combinedText.length > (ocrText?.length ?? 0)) {\n                const combined = runDeterministicExtraction(combinedText);\n                if (!deterministic.orderId && combined.orderId) {\n                    deterministic.orderId = combined.orderId;\n                    deterministic.notes.push('Order ID from combined OCR text.');\n                }\n                if (!deterministic.amount && combined.amount) {\n                    deterministic.amount = combined.amount;\n                    deterministic.notes.push('Amount from combined OCR text.');\n                }\n                if (!deterministic.orderDate && combined.orderDate) {\n                    deterministic.orderDate = combined.orderDate;\n                    deterministic.notes.push('Order date from combined OCR text.');\n                }\n                if (!deterministic.soldBy && combined.soldBy) {\n                    deterministic.soldBy = combined.soldBy;\n                    deterministic.notes.push('Seller info from combined OCR text.');\n                }\n                if (!deterministic.productName && combined.productName) {\n                    deterministic.productName = combined.productName;\n                    deterministic.notes.push('Product name from combined OCR text.');\n                }\n                if (!ocrText) {\n                    ocrText = combinedText;\n                    ocrLabel = 'combined';\n                }\n            }\n        }\n        if (!ocrText) {\n            console.warn('Order extract OCR failed: empty OCR output.');\n            return {\n                orderId: null,\n                amount: null,\n                confidenceScore: 15,\n                notes: 'OCR failed to read text. Please upload a clearer screenshot.',\n            };\n        }\n        if (env.AI_DEBUG_OCR) {\n            console.log('Order extract OCR', {\n                label: ocrLabel,\n                length: ocrText.length,\n                preview: ocrText.slice(0, 600),\n            });\n        }\n        // deterministic already computed from the best OCR pass above\n        const deterministicConfidence = deterministic.orderId && deterministic.amount ? 78 :\n            deterministic.orderId || deterministic.amount ? 72 : 0;\n        console.log('Order extract deterministic', {\n            orderId: deterministic.orderId,\n            amount: deterministic.amount,\n            confidence: deterministicConfidence,\n        });\n        let finalOrderId = deterministic.orderId;\n        let finalAmount = deterministic.amount;\n        let confidenceScore = deterministicConfidence;\n        const notes = [...deterministic.notes];\n        let aiUsed = false;\n        if (!(finalOrderId && finalAmount) && ai) {\n            for (const model of GEMINI_MODEL_FALLBACKS.slice(0, 3)) {\n                try {\n                    // eslint-disable-next-line no-await-in-loop\n                    const aiResult = await refineWithAi(model, ocrText, deterministic);\n                    if (!aiResult)\n                        continue;\n                    const aiSuggestedOrderId = sanitizeOrderId(aiResult.suggestedOrderId);\n                    const aiSuggestedAmount = typeof aiResult.suggestedAmount === 'number' && Number.isFinite(aiResult.suggestedAmount)\n                        ? aiResult.suggestedAmount\n                        : null;\n                    const aiConfidence = typeof aiResult.confidenceScore === 'number' && Number.isFinite(aiResult.confidenceScore)\n                        ? Math.max(0, Math.min(100, Math.round(aiResult.confidenceScore)))\n                        : 0;\n                    const orderIdVisible = aiSuggestedOrderId\n                        ? ocrText.toLowerCase().includes(aiSuggestedOrderId.toLowerCase())\n                        : false;\n                    const amountVisible = aiSuggestedAmount\n                        ? ocrText.includes(String(aiSuggestedAmount))\n                        : false;\n                    if (!finalOrderId && aiSuggestedOrderId && orderIdVisible) {\n                        finalOrderId = aiSuggestedOrderId;\n                        notes.push('AI suggested order ID validated against OCR text.');\n                    }\n                    if (!finalAmount && aiSuggestedAmount && amountVisible) {\n                        finalAmount = aiSuggestedAmount;\n                        notes.push('AI suggested amount validated against OCR text.');\n                    }\n                    if (finalOrderId && finalAmount && deterministic.orderId && deterministic.amount) {\n                        confidenceScore = 90;\n                        notes.push('AI agreed with deterministic extraction.');\n                    }\n                    else if (finalOrderId || finalAmount) {\n                        confidenceScore = Math.max(confidenceScore, deterministicConfidence || 55);\n                    }\n                    if (aiResult.notes)\n                        notes.push(aiResult.notes);\n                    aiUsed = true;\n                    console.log('Order extract AI', {\n                        suggestedOrderId: aiSuggestedOrderId,\n                        suggestedAmount: aiSuggestedAmount,\n                        confidence: aiConfidence,\n                    });\n                    break;\n                }\n                catch (innerError) {\n                    _lastError = innerError;\n                    continue;\n                }\n            }\n        }\n        if (!finalOrderId && !finalAmount) {\n            confidenceScore = 25;\n            notes.push('Unable to extract order details from OCR text.');\n        }\n        else if (!confidenceScore) {\n            confidenceScore = 55;\n        }\n        // Collect all extracted metadata\n        const finalOrderDate = deterministic.orderDate;\n        const finalSoldBy = deterministic.soldBy;\n        const finalProductName = deterministic.productName;\n        console.log('Order extract final', {\n            orderId: finalOrderId,\n            amount: finalAmount,\n            orderDate: finalOrderDate,\n            soldBy: finalSoldBy,\n            productName: finalProductName,\n            confidence: confidenceScore,\n            aiUsed,\n        });\n        return {\n            orderId: finalOrderId,\n            amount: finalAmount,\n            orderDate: finalOrderDate,\n            soldBy: finalSoldBy,\n            productName: finalProductName,\n            confidenceScore,\n            notes: notes.join(' '),\n        };\n    }\n    catch (error) {\n        console.error('Order extraction error:', error);\n        return {\n            orderId: null,\n            amount: null,\n            orderDate: null,\n            soldBy: null,\n            productName: null,\n            confidenceScore: 0,\n            notes: `Extraction failed: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        };\n    }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\services\\audit.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\services\\authz.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\services\\codes.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\services\\invites.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\services\\lineage.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\services\\orderEvents.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\services\\orderWorkflow.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\services\\passwords.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\services\\pushNotifications.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\services\\realtimeHub.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\services\\roleDocuments.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\services\\tokens.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\services\\walletService.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\utils\\mediatorCode.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\utils\\mobiles.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\utils\\money.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\utils\\uiMappers.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\validations\\admin.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\validations\\auth.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\validations\\brand.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\validations\\connections.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\validations\\invites.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\validations\\ops.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\validations\\orders.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\validations\\systemConfig.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\dist\\validations\\tickets.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\eslint.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\index.e2e.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\middleware\\auth.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-namespace","severity":2,"message":"ES2015 module syntax is preferred over namespaces.","line":25,"column":3,"nodeType":"TSModuleDeclaration","messageId":"moduleSyntaxIsPreferred","endLine":29,"endColumn":4,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\middleware\\errors.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\models\\Agency.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\models\\AuditLog.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\models\\Brand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\models\\Campaign.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\models\\Deal.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\models\\Invite.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\models\\MediatorProfile.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\models\\Order.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\models\\Payout.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\models\\PushSubscription.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\models\\ShopperProfile.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\models\\Suspension.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\models\\SystemConfig.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\models\\Ticket.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\models\\Transaction.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\models\\User.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\models\\Wallet.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\routes\\adminRoutes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\routes\\aiRoutes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\routes\\authRoutes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\routes\\brandRoutes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\routes\\healthRoutes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\routes\\mediaRoutes.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'env' is defined but never used. Allowed unused args must match /^_/u.","line":62,"column":29,"nodeType":"Identifier","messageId":"unusedVar","endLine":62,"endColumn":32}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Router } from 'express';\r\nimport type { Env } from '../config/env.js';\r\n\r\nconst MAX_IMAGE_BYTES = 4 * 1024 * 1024; // 4MB\r\nconst ALLOWED_PROTOCOLS = new Set(['http:', 'https:']);\r\n\r\n/**\r\n * Simple per-IP rate limiter for the public image proxy.\r\n * Allows `MAX_REQUESTS` requests per `WINDOW_MS` window per IP.\r\n */\r\nconst RATE_WINDOW_MS = 60_000; // 1 minute\r\nconst RATE_MAX_REQUESTS = 120; // generous limit for pages with many product cards\r\nconst ipHits = new Map<string, { count: number; resetAt: number }>();\r\n\r\nfunction isRateLimited(ip: string): boolean {\r\n  const now = Date.now();\r\n  const entry = ipHits.get(ip);\r\n  if (!entry || now >= entry.resetAt) {\r\n    ipHits.set(ip, { count: 1, resetAt: now + RATE_WINDOW_MS });\r\n    return false;\r\n  }\r\n  entry.count++;\r\n  return entry.count > RATE_MAX_REQUESTS;\r\n}\r\n\r\n// Periodically clean up stale entries to prevent memory leak\r\nsetInterval(() => {\r\n  const now = Date.now();\r\n  for (const [ip, entry] of ipHits) {\r\n    if (now >= entry.resetAt) ipHits.delete(ip);\r\n  }\r\n}, RATE_WINDOW_MS * 2).unref();\r\n\r\n/** Block requests to private / link-local / loopback addresses (SSRF protection). */\r\nfunction isPrivateHost(hostname: string): boolean {\r\n  const h = hostname.toLowerCase();\r\n  // Loopback\r\n  if (h === 'localhost' || h === '127.0.0.1' || h === '[::1]' || h === '::1') return true;\r\n  // Block encoded forms of loopback (e.g. 0x7f000001, 0177.0.0.1)\r\n  if (/^0[xo]/.test(h) || /^\\d+$/.test(h)) return true;\r\n  // IPv6 private / link-local ranges\r\n  if (h.startsWith('[')) {\r\n    const inner = h.slice(1, -1);\r\n    // fc00::/7 (unique local), fe80::/10 (link-local), ::1 (loopback)\r\n    if (/^f[cd]/i.test(inner) || /^fe[89ab]/i.test(inner) || inner === '::1') return true;\r\n  }\r\n  // RFC-1918 / link-local / metadata (IPv4)\r\n  const parts = hostname.split('.').map(Number);\r\n  if (parts.length === 4 && parts.every((n) => Number.isFinite(n))) {\r\n    if (parts[0] === 10) return true;\r\n    if (parts[0] === 172 && parts[1] >= 16 && parts[1] <= 31) return true;\r\n    if (parts[0] === 192 && parts[1] === 168) return true;\r\n    if (parts[0] === 169 && parts[1] === 254) return true; // AWS metadata etc.\r\n    if (parts[0] === 127) return true; // entire 127.0.0.0/8\r\n    if (parts[0] === 0) return true;\r\n  }\r\n  // Block cloud metadata hostnames\r\n  if (h === 'metadata.google.internal' || h === 'metadata.google.com') return true;\r\n  return false;\r\n}\r\n\r\nexport function mediaRoutes(env: Env): Router {\r\n  const router = Router();\r\n\r\n  // Public endpoint ΓÇö <img src=\"...\"> tags cannot send Authorization headers.\r\n  // SSRF protection (isPrivateHost) + per-IP rate limiting keep this safe.\r\n  router.get('/media/image', async (req, res) => {\r\n    const clientIp = (req.headers['x-forwarded-for'] as string)?.split(',')[0]?.trim() || req.ip || 'unknown';\r\n    if (isRateLimited(clientIp)) {\r\n      res.status(429).json({ error: { code: 'TOO_MANY_REQUESTS', message: 'rate limit exceeded' } });\r\n      return;\r\n    }\r\n    const rawUrl = String(req.query.url || '').trim();\r\n    if (!rawUrl) {\r\n      res.status(400).json({ error: { code: 'BAD_REQUEST', message: 'url required' } });\r\n      return;\r\n    }\r\n\r\n    let target: URL;\r\n    try {\r\n      target = new URL(rawUrl);\r\n    } catch {\r\n      res.status(400).json({ error: { code: 'BAD_REQUEST', message: 'invalid url' } });\r\n      return;\r\n    }\r\n\r\n    if (!ALLOWED_PROTOCOLS.has(target.protocol)) {\r\n      res.status(400).json({ error: { code: 'BAD_REQUEST', message: 'invalid protocol' } });\r\n      return;\r\n    }\r\n\r\n    if (isPrivateHost(target.hostname)) {\r\n      res.status(400).json({ error: { code: 'BAD_REQUEST', message: 'private addresses not allowed' } });\r\n      return;\r\n    }\r\n\r\n    const controller = new AbortController();\r\n    const timeout = setTimeout(() => controller.abort(), 8000);\r\n\r\n    try {\r\n      const response = await fetch(target.toString(), {\r\n        signal: controller.signal,\r\n        headers: {\r\n          'User-Agent': 'Mozilla/5.0 (compatible; BUZZMA/1.0)',\r\n          Accept: 'image/*,*/*;q=0.8',\r\n        },\r\n      });\r\n\r\n      if (!response.ok || !response.body) {\r\n        res.status(404).end();\r\n        return;\r\n      }\r\n\r\n      const contentType = response.headers.get('content-type') || 'image/jpeg';\r\n      const contentLength = Number(response.headers.get('content-length') || 0);\r\n      if (contentLength && contentLength > MAX_IMAGE_BYTES) {\r\n        res.status(413).end();\r\n        return;\r\n      }\r\n\r\n      const arrayBuffer = await response.arrayBuffer();\r\n      if (arrayBuffer.byteLength > MAX_IMAGE_BYTES) {\r\n        res.status(413).end();\r\n        return;\r\n      }\r\n\r\n      res.setHeader('Content-Type', contentType);\r\n      res.setHeader('Cache-Control', 'public, max-age=86400');\r\n      res.send(Buffer.from(arrayBuffer));\r\n    } catch {\r\n      res.status(404).end();\r\n    } finally {\r\n      clearTimeout(timeout);\r\n    }\r\n  });\r\n\r\n  return router;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\routes\\notificationsRoutes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\routes\\opsRoutes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\routes\\ordersRoutes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\routes\\productsRoutes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\routes\\realtimeRoutes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\routes\\ticketsRoutes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\scripts\\checkAiKey.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\scripts\\migrate.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\scripts\\migrations\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\scripts\\migrations\\m20260108_indexes_softdelete_unique.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\scripts\\migrations\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\scripts\\repairRoleDocuments.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\scripts\\resetSeed.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\scripts\\resetToAdmin.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\scripts\\seedAdmin.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\scripts\\seedDev.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\scripts\\seedE2E.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\scripts\\test-extraction-logic.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\scripts\\wipe.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\seeds\\admin.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\seeds\\dev.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\seeds\\e2e.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\seeds\\seed.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\services\\aiService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\services\\audit.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\services\\authz.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\services\\codes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\services\\invites.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\services\\lineage.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\services\\orderEvents.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\services\\orderWorkflow.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\services\\passwords.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\services\\pushNotifications.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\services\\realtimeHub.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\services\\roleDocuments.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\services\\tokens.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\services\\walletService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\tests\\admin.invites.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\tests\\ai.routes.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\tests\\ai.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\tests\\auth.register.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\tests\\auth.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\tests\\bad-json.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\tests\\brand.payouts.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\tests\\campaign.assign-slots.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\tests\\cors.origins.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\tests\\deals.publish.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\tests\\errors.production.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\tests\\extraction.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\tests\\health.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\tests\\invites.delete.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\tests\\mediator.pending-approval.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\tests\\mongoPlaceholder.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\tests\\order.step-verification.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\tests\\orders.products.ops.brand.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\tests\\rbac.policy.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\tests\\realtime.health.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\tests\\seed.admin.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\tests\\smoke.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\tests\\tickets.routes.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\types\\seedrandom.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\utils\\mediatorCode.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\utils\\mobiles.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\utils\\money.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\utils\\uiMappers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\validations\\admin.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\validations\\auth.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\validations\\brand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\validations\\connections.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\validations\\invites.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\validations\\ops.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\validations\\orders.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\validations\\systemConfig.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\validations\\tickets.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Gaurav\\Buzzma\\MOBO\\backend\\vitest.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]
