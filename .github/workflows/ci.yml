# ─────────────────────────────────────────────────────────────────────
# CI / CD  —  MOBO Ecosystem (Production-Hardened)
# ─────────────────────────────────────────────────────────────────────
# Security posture:
#   - All actions pinned to full SHA (supply-chain protection)
#   - Least-privilege permissions per job
#   - Deploy concurrency prevents parallel production mutations
#   - DATABASE_URL only available in deploy job (secret isolation)
#   - Migration safety checker blocks destructive DDL
#   - Post-deploy health verification before declaring success
# ─────────────────────────────────────────────────────────────────────
name: CI / CD

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

# ─── Global defaults ─────────────────────────────────────────────────
# Least-privilege: no permissions by default, each job opts in
permissions: {}

env:
  NODE_VERSION: '20'
  NPM_VERSION: '11.6.2'

# ─── CI concurrency: cancel stale PR runs, NEVER cancel deploys ──────
# Deploy has its own concurrency group below
concurrency:
  group: ci-${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: ${{ github.event_name == 'pull_request' }}

jobs:
  # ═══════════════════════════════════════════════════════════════════
  #  1. Lint, Type-check & Security Audit
  # ═══════════════════════════════════════════════════════════════════
  lint:
    name: '🔍 Lint & Type-check'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    permissions:
      contents: read
    steps:
      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          persist-credentials: false

      - name: Setup Node ${{ env.NODE_VERSION }}
        uses: actions/setup-node@39370e3970a6d050c480ffad4ff0ed4d3fdee5af # v4.1.0
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm

      - name: Pin npm version
        run: npm i -g npm@${{ env.NPM_VERSION }}

      - name: Install dependencies
        run: npm ci

      - name: Generate Prisma client
        run: npm -w @mobo/backend run pg:generate

      - name: Security audit (high + critical)
        run: npm audit --audit-level=high --omit=dev || echo "::warning::npm audit found high/critical vulnerabilities — review before merging"

      - name: Lint (root)
        run: npm run lint

      - name: Lint (backend)
        run: npm -w @mobo/backend run lint

      - name: Type-check (backend tsc)
        run: npm -w @mobo/backend run build

  # ═══════════════════════════════════════════════════════════════════
  #  2. Backend Unit / Integration Tests (Vitest)
  # ═══════════════════════════════════════════════════════════════════
  test-backend:
    name: '🧪 Backend Tests'
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: lint
    permissions:
      contents: read

    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_USER: mobo_ci
          POSTGRES_PASSWORD: mobo_ci_pass
          POSTGRES_DB: mobo_ci
        ports:
          - 5432:5432
        options: >-
          --health-cmd "pg_isready -U mobo_ci"
          --health-interval 5s
          --health-timeout 5s
          --health-retries 10

    env:
      DATABASE_URL: postgresql://mobo_ci:mobo_ci_pass@localhost:5432/mobo_ci
      NODE_ENV: test

    steps:
      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          persist-credentials: false

      - name: Setup Node ${{ env.NODE_VERSION }}
        uses: actions/setup-node@39370e3970a6d050c480ffad4ff0ed4d3fdee5af # v4.1.0
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm

      - name: Pin npm version
        run: npm i -g npm@${{ env.NPM_VERSION }}

      - name: Install dependencies
        run: npm ci

      - name: Generate Prisma client
        run: npm -w @mobo/backend run pg:generate

      - name: Check migration safety
        run: cd backend && bash scripts/check-migration-safety.sh

      - name: Apply Prisma migrations to CI database
        run: cd backend && npx prisma migrate deploy

      - name: Verify migration state
        run: cd backend && npx prisma migrate status

      - name: Run Vitest with coverage
        run: npm run test:backend -- --coverage --reporter=json --reporter=default --outputFile=backend/vitest-result.json
        continue-on-error: false

      - name: Upload coverage report
        if: always()
        uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
        with:
          name: coverage-report
          path: |
            backend/coverage/
          retention-days: 14

      - name: Upload test results
        if: failure()
        uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
        with:
          name: vitest-results
          path: |
            backend/vitest-result.json
            backend/vitest-output.txt
          retention-days: 7

  # ═══════════════════════════════════════════════════════════════════
  #  3. Build All Portals
  # ═══════════════════════════════════════════════════════════════════
  build-apps:
    name: '🏗️ Build Portals'
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: lint
    permissions:
      contents: read

    steps:
      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          persist-credentials: false

      - name: Setup Node ${{ env.NODE_VERSION }}
        uses: actions/setup-node@39370e3970a6d050c480ffad4ff0ed4d3fdee5af # v4.1.0
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm

      - name: Pin npm version
        run: npm i -g npm@${{ env.NPM_VERSION }}

      - name: Install dependencies
        run: npm ci

      - name: Install Next.js SWC binary for Linux
        run: npm i --no-save @next/swc-linux-x64-gnu

      - name: Generate Prisma client
        run: npm -w @mobo/backend run pg:generate

      - name: Build backend (tsc)
        run: npm -w @mobo/backend run build

      - name: Cache Next.js build output
        uses: actions/cache@5a3ec84eff668545956fd18022155c47e93e2684 # v4.2.3
        with:
          path: |
            apps/*/.next/cache
          key: nextjs-${{ runner.os }}-${{ hashFiles('package-lock.json') }}-${{ hashFiles('apps/**/*.tsx', 'apps/**/*.ts', 'shared/**/*.tsx', 'shared/**/*.ts') }}
          restore-keys: |
            nextjs-${{ runner.os }}-${{ hashFiles('package-lock.json') }}-
            nextjs-${{ runner.os }}-

      - name: Build all portals
        run: npm run build:apps

  # ═══════════════════════════════════════════════════════════════════
  #  4. E2E Tests (Playwright) — GATE (failures BLOCK deploy)
  # ═══════════════════════════════════════════════════════════════════
  test-e2e:
    name: '🎭 E2E Tests'
    runs-on: ubuntu-latest
    timeout-minutes: 25
    needs: [test-backend, build-apps]
    permissions:
      contents: read

    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_USER: mobo_ci
          POSTGRES_PASSWORD: mobo_ci_pass
          POSTGRES_DB: mobo_ci
        ports:
          - 5432:5432
        options: >-
          --health-cmd "pg_isready -U mobo_ci"
          --health-interval 5s
          --health-timeout 5s
          --health-retries 10

    env:
      DATABASE_URL: postgresql://mobo_ci:mobo_ci_pass@localhost:5432/mobo_ci
      NODE_ENV: test

    steps:
      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          persist-credentials: false

      - name: Setup Node ${{ env.NODE_VERSION }}
        uses: actions/setup-node@39370e3970a6d050c480ffad4ff0ed4d3fdee5af # v4.1.0
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm

      - name: Pin npm version
        run: npm i -g npm@${{ env.NPM_VERSION }}

      - name: Install dependencies
        run: npm ci

      - name: Install Next.js SWC binary for Linux
        run: npm i --no-save @next/swc-linux-x64-gnu

      - name: Generate Prisma client
        run: npm -w @mobo/backend run pg:generate

      - name: Apply Prisma migrations to CI database
        run: cd backend && npx prisma migrate deploy

      - name: Cache Playwright browsers
        id: pw-cache
        uses: actions/cache@5a3ec84eff668545956fd18022155c47e93e2684 # v4.2.3
        with:
          path: ~/.cache/ms-playwright
          key: pw-${{ runner.os }}-${{ hashFiles('package-lock.json') }}
          restore-keys: pw-${{ runner.os }}-

      - name: Install Playwright browsers
        if: steps.pw-cache.outputs.cache-hit != 'true'
        run: npx playwright install --with-deps

      - name: Install Playwright OS dependencies
        if: steps.pw-cache.outputs.cache-hit == 'true'
        run: npx playwright install-deps

      # ⛔  NO continue-on-error — E2E failures BLOCK the pipeline
      # CI runs API-only tests (no portals) for speed & reliability.
      # Full smoke/UI tests run locally with all 6 dev servers.
      - name: Run Playwright E2E tests (API only)
        timeout-minutes: 15
        env:
          NODE_OPTIONS: '--max-old-space-size=4096 --no-deprecation'
        run: npx playwright test --project=api

      - name: Upload Playwright report
        if: always()
        uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
        with:
          name: playwright-report
          path: |
            test-results/
            playwright-report/
          retention-days: 14

  # ═══════════════════════════════════════════════════════════════════
  #  5. Deploy — migrate production + Render deploy hook
  #     Only on push to main or develop (never on PRs)
  # ═══════════════════════════════════════════════════════════════════
  #
  #  SAFETY:
  #   - Separate concurrency group prevents parallel deploys
  #   - cancel-in-progress: false — NEVER cancel a running deploy
  #   - DATABASE_URL is only available in this job (secret isolation)
  #   - Migration safety re-checked before touching production
  #   - Post-deploy health check verifies the service is alive
  # ═══════════════════════════════════════════════════════════════════
  deploy:
    name: '🚀 Deploy'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [test-e2e]
    if: >-
      github.event_name == 'push' &&
      (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop')
    permissions:
      contents: read
    # Deploy gets its OWN concurrency group — never cancelled mid-flight
    concurrency:
      group: deploy-production
      cancel-in-progress: false

    env:
      GIT_SHA: ${{ github.sha }}
      BUILD_TIME: ${{ github.event.head_commit.timestamp }}

    steps:
      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          persist-credentials: false

      - name: Setup Node ${{ env.NODE_VERSION }}
        uses: actions/setup-node@39370e3970a6d050c480ffad4ff0ed4d3fdee5af # v4.1.0
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm

      - name: Pin npm version
        run: npm i -g npm@${{ env.NPM_VERSION }}

      - name: Install dependencies
        run: npm ci

      - name: Generate Prisma client
        run: npm -w @mobo/backend run pg:generate

      - name: Check migration safety (production)
        run: cd backend && bash scripts/check-migration-safety.sh

      # Fail-fast if DATABASE_URL secret is not configured
      - name: Validate DATABASE_URL is set
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
        run: |
          if [ -z "$DATABASE_URL" ]; then
            echo "::error::DATABASE_URL secret is not configured — skipping deploy"
            exit 1
          fi
          echo "✅ DATABASE_URL is configured"
          # Debug: show URL structure (masked credentials)
          echo "URL params: $(echo "$DATABASE_URL" | grep -oP '\?.*' | sed 's/=[^&]*/=***/g' || echo '(none)')"

      - name: Verify database connectivity & permissions
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          NODE_TLS_REJECT_UNAUTHORIZED: '0'
        run: |
          cd backend
          # Determine schema based on branch
          if [ "${{ github.ref }}" = "refs/heads/main" ]; then
            SCHEMA="buzzma_production"
          else
            SCHEMA="buzzma_test"
          fi
          echo "DB_SCHEMA=$SCHEMA" >> "$GITHUB_ENV"
          echo "Using schema: $SCHEMA"

          # Build the correctly-fixed DATABASE_URL (Node.js handles URL params safely)
          # Adds search_path + sslaccept for Prisma Rust engine compatibility
          FIXED_URL=$(node -e '
            var schema = process.argv[1];
            var u = process.env.DATABASE_URL || "";
            var i = u.indexOf("?");
            var base = i >= 0 ? u.substring(0, i) : u;
            var qs = i >= 0 ? u.substring(i + 1) : "";
            var params = qs ? qs.split("&").filter(function(p) {
              return !p.startsWith("search_path=") && !p.startsWith("sslaccept=");
            }) : [];
            params.push("search_path=" + schema);
            params.push("sslaccept=accept_invalid_certs");
            process.stdout.write(base + "?" + params.join("&"));
          ' "$SCHEMA")
          # Save for all subsequent deploy steps
          echo "DEPLOY_DATABASE_URL=$FIXED_URL" >> "$GITHUB_ENV"
          echo "::add-mask::$FIXED_URL"

          # Show masked URL structure for debugging
          echo "$FIXED_URL" | sed 's/:\/\/[^:]*:[^@]*@/:\/\/***:***@/'

          DEPLOY_URL="$FIXED_URL" node -e '
            const { Client } = require("pg");
            const c = new Client({
              connectionString: process.env.DEPLOY_URL,
              ssl: { rejectUnauthorized: false }
            });
            const schema = process.argv[1];
            (async () => {
              await c.connect();
              const sp = await c.query("SHOW search_path");
              console.log("search_path:", sp.rows[0].search_path);
              const cs = await c.query("SELECT current_schema()");
              console.log("current_schema:", cs.rows[0].current_schema);

              // Check if schema exists
              const res = await c.query(
                "SELECT 1 FROM information_schema.schemata WHERE schema_name = $1",
                [schema]
              );
              if (res.rows.length === 0) {
                try {
                  await c.query("CREATE SCHEMA " + schema);
                  console.log("✅ Created schema " + schema);
                } catch (createErr) {
                  console.error("::error::Cannot create schema " + schema + ": " + createErr.message);
                  process.exit(1);
                }
              } else {
                console.log("✅ Schema " + schema + " exists");
              }

              // Verify CREATE privilege by creating+dropping a test table
              await c.query("SET search_path TO " + schema);
              try {
                await c.query("CREATE TABLE IF NOT EXISTS _ci_privilege_test (id int)");
                await c.query("DROP TABLE IF EXISTS _ci_privilege_test");
                console.log("✅ CREATE privilege verified on " + schema);
              } catch (privErr) {
                console.error("::error::No CREATE privilege on " + schema + ": " + privErr.message);
                process.exit(1);
              }

              console.log("✅ Connectivity OK");
              await c.end();
            })().catch(e => { console.error("::error::DB check failed: " + e.message); process.exit(1); });
          ' "$SCHEMA"

      - name: Prepare migration state
        env:
          NODE_TLS_REJECT_UNAUTHORIZED: '0'
        run: |
          export DATABASE_URL="${DEPLOY_DATABASE_URL}"
          echo "DATABASE_URL is ${#DATABASE_URL} chars (empty=${DATABASE_URL:+no}${DATABASE_URL:-YES})"
          cd backend

          # Step 1: Pre-create _prisma_migrations + clean incomplete entries
          node -e '
            const fs = require("fs");
            const { Client } = require("pg");
            const c = new Client({
              connectionString: process.env.DATABASE_URL,
              ssl: { rejectUnauthorized: false }
            });
            const schema = process.argv[1];
            (async () => {
              await c.connect();
              console.log("Connected. Preparing migration state for schema:", schema);

              const sp = await c.query("SHOW search_path");
              console.log("search_path:", sp.rows[0].search_path);

              await c.query(
                "CREATE TABLE IF NOT EXISTS \"_prisma_migrations\" (" +
                "id VARCHAR(36) PRIMARY KEY DEFAULT gen_random_uuid()::text, " +
                "checksum VARCHAR(64) NOT NULL, " +
                "finished_at TIMESTAMPTZ, " +
                "migration_name VARCHAR(255) NOT NULL UNIQUE, " +
                "logs TEXT, " +
                "rolled_back_at TIMESTAMPTZ, " +
                "started_at TIMESTAMPTZ DEFAULT now(), " +
                "applied_steps_count INTEGER DEFAULT 0)"
              );
              console.log("_prisma_migrations table ready");

              const del = await c.query(
                "DELETE FROM \"_prisma_migrations\" WHERE finished_at IS NULL"
              );
              if (del.rowCount > 0) console.log("Cleaned", del.rowCount, "incomplete entries");

              // Check for existing tables
              const r = await c.query(
                "SELECT table_name FROM information_schema.tables " +
                "WHERE table_schema = $1 AND table_type = " + String.fromCharCode(39) + "BASE TABLE" + String.fromCharCode(39) +
                " AND table_name != " + String.fromCharCode(39) + "_prisma_migrations" + String.fromCharCode(39) +
                " ORDER BY table_name",
                [schema]
              );

              const hasTables = r.rows.length > 0;
              if (hasTables) {
                console.log("Found", r.rows.length, "tables:", r.rows.map(x => x.table_name).join(", "));
              } else {
                console.log("Schema is empty — no existing tables");
              }
              fs.writeFileSync("/tmp/has_tables.txt", hasTables ? "yes" : "no");

              await c.end();
              console.log("Done.");
            })().catch(e => {
              console.error("::error::Prepare migration state failed:", e.message);
              process.exit(1);
            });
          ' "${DB_SCHEMA}"

          HAS_TABLES=$(cat /tmp/has_tables.txt 2>/dev/null || echo "no")
          echo "Has existing tables: $HAS_TABLES"

          if [ "$HAS_TABLES" = "yes" ]; then
            echo "⚡ Schema has tables — resolving all existing migrations"
            for m in 0_baseline 20260226235614_add_order_ai_verification 20260227021440_add_missing_indexes 20260228000000_add_ops_dashboard_composite_index 20260228010000_add_deal_mediator_composite_index; do
              echo "  Resolving $m..."
              npx prisma migrate resolve --applied "$m" 2>&1 || true
            done
            echo "✅ All existing migrations resolved"
          else
            echo "✅ Schema is empty — migrations will run fresh from baseline"
          fi

      - name: Apply Prisma migrations to production database
        env:
          NODE_TLS_REJECT_UNAUTHORIZED: '0'
        run: |
          export DATABASE_URL="${DEPLOY_DATABASE_URL}"
          echo "Migrating schema: ${DB_SCHEMA}"
          cd backend

          LOGFILE="/tmp/deploy-migrations.log"
          > "$LOGFILE"

          # Run prisma migrate deploy
          echo "=== prisma migrate deploy ===" | tee -a "$LOGFILE"
          set +e
          npx prisma migrate deploy 2>&1 | tee -a "$LOGFILE"
          MIGRATE_EXIT=${PIPESTATUS[0]}
          set -e

          if [ $MIGRATE_EXIT -eq 0 ]; then
            echo "✅ prisma migrate deploy succeeded" | tee -a "$LOGFILE"
            exit 0
          fi
          echo "⚠️ prisma migrate deploy failed (exit $MIGRATE_EXIT)" | tee -a "$LOGFILE"

          # Fallback: Direct SQL via deploy-migrate.js (bypasses Prisma Rust engine)
          echo "=== Fallback: Direct SQL via deploy-migrate.js ===" | tee -a "$LOGFILE"
          set +e
          node scripts/deploy-migrate.js 2>&1 | tee -a "$LOGFILE"
          DIRECT_EXIT=${PIPESTATUS[0]}
          set -e

          if [ $DIRECT_EXIT -eq 0 ]; then
            echo "✅ Direct SQL migration succeeded" | tee -a "$LOGFILE"
            exit 0
          fi

          # Capture full error output in annotation (visible without auth)
          echo "## Deploy Migration Log" >> "$GITHUB_STEP_SUMMARY"
          echo '```' >> "$GITHUB_STEP_SUMMARY"
          cat "$LOGFILE" >> "$GITHUB_STEP_SUMMARY"
          echo '```' >> "$GITHUB_STEP_SUMMARY"

          # Put error details in annotation (visible on public summary page)
          ERROR_DETAIL=$(cat "$LOGFILE" | tail -80 | head -c 2000)
          # Encode for GitHub annotation format
          ERROR_DETAIL="${ERROR_DETAIL//'%'/%25}"
          ERROR_DETAIL="${ERROR_DETAIL//$'\n'/%0A}"
          ERROR_DETAIL="${ERROR_DETAIL//$'\r'/%0D}"
          echo "::error::Migration failed. Output:%0A${ERROR_DETAIL}"
          exit 1

      - name: Upload deploy log
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: deploy-migration-log
          path: /tmp/deploy-migrations.log
          retention-days: 7

      - name: Verify production migration state
        env:
          NODE_TLS_REJECT_UNAUTHORIZED: '0'
        run: |
          export DATABASE_URL="${DEPLOY_DATABASE_URL}"
          cd backend
          echo "--- Migration status ---"
          npx prisma migrate status 2>&1 || true
          echo "--- Verifying schema tables ---"
          node -e '
            const { Client } = require("pg");
            const c = new Client({
              connectionString: process.env.DATABASE_URL,
              ssl: { rejectUnauthorized: false }
            });
            const schema = process.argv[1];
            (async () => {
              await c.connect();
              const r = await c.query(
                "SELECT table_name FROM information_schema.tables WHERE table_schema = $1 AND table_type = \x27BASE TABLE\x27 ORDER BY table_name",
                [schema]
              );
              console.log("Tables in " + schema + ": " + r.rows.map(x => x.table_name).join(", "));
              console.log("Total: " + r.rows.length + " tables");
              await c.end();
            })().catch(e => { console.error(e.message); });
          ' "${DB_SCHEMA}"

      - name: Trigger Render backend deploy
        if: success()
        env:
          RENDER_DEPLOY_HOOK: ${{ secrets.RENDER_DEPLOY_HOOK }}
        run: |
          if [ -z "$RENDER_DEPLOY_HOOK" ]; then
            echo "::warning::RENDER_DEPLOY_HOOK not set — skipping deploy trigger"
            exit 0
          fi
          echo "Triggering Render deploy for SHA $GIT_SHA…"
          HTTP_STATUS=$(curl -sf -o /dev/null -w "%{http_code}" "$RENDER_DEPLOY_HOOK")
          if [ "$HTTP_STATUS" -ge 200 ] && [ "$HTTP_STATUS" -lt 300 ]; then
            echo "✅ Render deploy triggered (HTTP $HTTP_STATUS)"
          else
            echo "::error::Render deploy hook returned HTTP $HTTP_STATUS"
            exit 1
          fi

      - name: Post-deploy health check
        if: success()
        env:
          HEALTH_URL: ${{ secrets.HEALTH_URL }}
        run: |
          # Default health URL if secret not set
          URL="${HEALTH_URL:-https://mobo-agig.onrender.com/api/health}"
          echo "Waiting 30s for Render to pick up deploy…"
          sleep 30

          RETRIES=5
          for i in $(seq 1 $RETRIES); do
            HTTP_STATUS=$(curl -sf -o /tmp/health.json -w "%{http_code}" "$URL" 2>/dev/null || echo "000")
            if [ "$HTTP_STATUS" = "200" ]; then
              echo "✅ Health check passed (attempt $i/$RETRIES)"
              cat /tmp/health.json | head -c 500
              echo ""
              exit 0
            fi
            echo "⏳ Health check attempt $i/$RETRIES — HTTP $HTTP_STATUS, retrying in 15s…"
            sleep 15
          done
          echo "::warning::Health check did not pass after $RETRIES attempts — Render may still be deploying"
